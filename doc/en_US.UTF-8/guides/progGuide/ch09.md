
# Accessing the Data-Typing Database


This chapter describes the data-typing functions and how to use the data-
typing database.










# Summary


Data typing provides an extension to the attributes of files and data beyond
what is provided by the traditional UNIX file systems. These extensions consist
of attributes, such as icon names, descriptions, and actions, that can be
performed on files and data. This information is stored in name/value pairs in
theDATA_ATTRIBUTEStable (or database). The desktop uses a certain set ofDATA_ATTRIBUTES, described in the following paragraphs. TheDATA_ATTRIBUTEStable is extendable for future and application-specific
growth, although extending this table is not recommended because other
applications may not check the additions.

Data is matched with a specific file or data entry in aDATA_CRITERIAtable.
TheDATA_CRITERIAtable entries are sorted in decreasing order from most
specific to least specific. For example,/usr/lib/lib*is more specific than/usr/*and would, therefore, appear first. When a request to type a file or
data is made, the table is checked in sequence to find the best match using the
information provided either from the file or from the data. When an
information and entry match is found,DATA_ATTRIBUTES_NAMEis used to
find the properDATA_ATTRIBUTESentry.
# Library and Header Filesdata typinglibrarylibrarydata typingactionslibrarylibraryactions<Filename>libDtSvc<Default Para Font> library<Filename>libXm<Default Para Font> library<Filename>libX11<Default Para Font> library


To use data typing, you need to link to thelibDtSvclibrary. Actions are
usually loaded with the data-typing information. Actions require links to thelibXmandlibX11libraries. The header files areDt/Dts.handDt/Dt.h.
# Demo Programdata typingdemo programdemo programdata typing


A demo program containing an example of how to use the data-typing
database is in/usr/dt/examples/dtdts/datatypes/datatyping.c.
# Data Criteria and Data Attributesdata typingdata criteriadata criteriadata attributesdata typingdata attributes


Data typing consists of two parts:

A database that stores data criteria and data attributes

A collection of routines that query the database

The attributes ofdata typingcriteriacriteria, data typingdata criteria, in alphabetical order, are:

CONTENT

DATA_ATTRIBUTES_NAME

LINK_NAME

LINK_PATH

MODE

NAME_PATTERN

PATH_PATTERN

describes the data criteria in the order in which you are most likely to
use them.
# Data Criteria in Order of Most Likely Use


`Criteria`

`Description`

`Typical Usage`

DATA_ATTRIBUTES_NAME

The name of this type of data. This value is arecord_namein the data attributes table.

POSTSCRIPT

NAME_PATTERN

A shell pattern-matching expression describing the file
names that could match this data. The default is an empty
string, which means to ignore file patterns in matching.

*.ps

CONTENT

Three values that are interpreted as the start, type, and
value fields of the magic file used by the file utility. See
thefile(1) man page for more information. The default
is an empty field, which means to ignore contents in
matching. The following types are examples of what can
be matched: string, byte, short, long, and file name.

0 string !&percnt;

MODE

A string of zero to four characters that match the mode
field of astatstructure. See thestat(2)man page for
more information. The first character indicates:

dmatches a directory

smatches a socket

lmatches a symbolic link

fmatches a regular file

bmatches a block file

cmatches a character special file

f&!x

The characters listed below can be either the first or
subsequent characters:

rmatches any file with any of its user, group, or
other read permission bits set.

wmatches any file with any of its user, group, or
other write permission bits set.

xmatches any file with any of its user, group, or
other execute or directory-search permission
bits set.

For example, theMODEfield offrwmatches any regular
file that is readable or writable;xmatches any file with
any of its executable or search bits set.

The default is an empty field, which means to ignore the
mode in matching.

PATH_PATTERN

A shell pattern-matching expression describing the
absolute path names that could match this data. The
default is an empty string, which means to ignore path
patterns in matching.

*/`mysubdir`/*

LINK_NAME

Seedtdtsfile(4)man page.

LINK_PATH

Seedtdtsfile(4)man page.

Some of the more common attributes of data types, in alphabetical order, are:

ACTIONS

COPY_TO_ACTION

DESCRIPTION

ICON

INSTANCE_ICON

IS_EXECUTABLE

IS_TEXT

LINK_TO_ACTION

MEDIA

MIME_TYPE

MOVE_TO_ACTION

NAME_TEMPLATE

PROPERTIES

X400_TYPE

describes the data attributes in the order in which you are most likely
to use them.
# Data Attributes in Order of Most Likely Use


`Criteria`

`Description`

`Typical Usage`

DESCRIPTION

A human-readable description of this data. If this
field isNULLor is not included in the data attribute
record, the name of the data attribute should be used.

This is a PostScript page
description.

ICON

The name of the icon to be used for this data. If this
field isNULLor is not included in the data attribute
record, the standard icon should be used. Seedtdtsfile(4)for more details on icon naming.

Dtps

PROPERTIES

Keywords to indicate properties for this data. Valid
values are invisible and visible. If this field isNULLor
is not included in the data attribute record, the visible
property should be assumed. Use this if you want to
completely hide files from the user.

invisible

ACTIONS

A list of actions that can be performed on this data.
This list refers to names in the action table for actions
that are to be presented to the user for objects of this
type. If this field isNULLor is not included in the data
attribute record, no action is available.

Open,Print

NAME_TEMPLATE Field

A string used to create a new file for data of this type.
The string is passed tosprintf(3) with the file
name as the single argument. The default is empty.
Contrast this field with theNAME_PATTERNfield of
the data criteria table in that the template is used to
create a specific file, such as&percnt;s.c, whereas the
pattern is used to find files, such as*.c.

&percnt;s.ps

IS_EXECUTABLE Field

A string-Boolean value that tells users of this data
type that it can be executed as an application. IfIS_EXECUTABLEis set totrue(seeDtDtsIsTrue()) the data is executable. If this field
isNULL, is not included in the data attribute record,
or is not set to true, then the data is considered not
executable.

true

MOVE_TO_ACTION

The name of an action to be invoked when an object
is moved to the current object.

FILESYSTEM_MOVE

COPY_TO_ACTION

The name of an action to be invoked when an object
is copied to the current object.

FILESYSTEM_COPY

LINK_TO_ACTION

The name of an action to be invoked when an object
is linked to the current object.

FILESYSTEM_LINK

IS_TEXT

A string-Boolean value that tells users of this data
type that it is suitable for manipulation (viewing or
editing) in a text editor or text widget. TheIS_TEXTfield is set totrue(seeDtDtsIsTrue()) if the data
is textual in nature and if it should be presented to
the user in text form. Criteria for making this
determination include whether data consists of
human language, is generated and maintained
manually, is usefully viewable and editable in a text
editor, or contains no (or only minimal) structuring
and formatting information.

Seefor more
examples.

If theIS_TEXTfield istrue, the data is eligible to be
displayed directly by an application. That is, the
application can load the data directly into a text
editing widget, such asXmText.

MEDIA Field

The names in theMEDIAname space describe the
form of the data itself.MEDIAnames are used as
ICCCM selection targets, named in theMEDIAfield of
the data-type records, and used in the type parameter
of ToolTalk Media Exchange messages.

TheMEDIAname space is a subset of the name space
of selection target atoms as defined by the ICCCM.
All selection targets that specify a data format are
validMEDIAnames, and all validMEDIAnames can
be used directly as selection targets. Some selection
targets specify an attribute of the selection (for
example,LIST_LENGTH) or a side effect to occur (for
example,DELETE), rather than a data format. These
attribute selection targets are not part of theMEDIAname space.

POSTSCRIPT

MIME_TYPE

MEDIAis the desktop internal, unique name for data
types. However, other external naming authorities
have also established name spaces. Multipurpose
Internet Message Extensions (MIME), as described in
the referenced MIME RFC, is one of those external
registries, and is the standard-type name space for the
desktop mailer.

application/postscript

X400_TYPE

X.400 types are similar in structure to theMEDIAtype,
but are formatted using different rules and have
different naming authorities.

1 2 840 113556 3 2 850

INSTANCE_ICON Field

The name of the icon to be used for this instance of
data, typically a value such as&percnt;`name`&percnt;.icon[Bug indtdtsfile(4)man page, too.] IfINSTANCE_ICONis set, the application should use it instead ofICON. If
this field isNULLor is not included in the data
attribute record, theICONfield should be used.

/`myicondir`/&percnt;`name`&percnt;.bm

DATA_HOST

TheDATA_HOSTattribute is not a field that can be
added to the data attributes table in the*.dtfile, but
it may be returned to an application reading
attributes from the table. The data-typing service
adds this attribute automatically to indicate the host
system from which the data type was loaded. If this
field isNULLor is not included in the data attribute
record, the data type was loaded from the local
system.

TheIS_TEXTfield differs from the text attribute of theMIME_TYPEfield,
which is theMIMEcontent type, as described in the referencedMIME_ RFC. TheMIMEcontent type determines whether the data consists of textual characters
or byte values. If the data consists of textual characters, and the data is labeled
astext/*, theIS_TEXTfield determines whether it is appropriate for the data
to be presented to users in textual form.

shows some examples ofIS_TEXTusage with differentMIME_TYPEattributes.
# IS_TEXT Attribute Examples


`Description and MIME_TYPE Attribute`

`IS_TEXT Value`

Human language encoded in ASCII withMIME_TYPE
text/plain

IS_TEXT true

Human language encoded in E*UC, JIS, Unicode, or an ISO
Latin charset withMIME_TYPE text/plain;
charset=XXX

IS_TEXT true

CalendarAppointmentAttrs with aMIME_TYPE text/plain

IS_TEXT false

HyperText Markup Language (HTML) with aMIME_TYPE
text/html

IS_TEXT true

PostScript withMIME_TYPE application/postscript

IS_TEXT false

C program source (C_SRC) withMIME_TYPE text/plain

IS_TEXT true

Bitmaps and pixmaps (XBMandXPM) withMIME_TYPE
text/plain

IS_TEXT false

Project or module files for the desktop application building
service withMIME_TYPE text/plain

IS_TEXT false

Shell scripts withMIME_TYPE text/plain

IS_TEXT false

Encoded text produced byuuencode(1) withMIME_TYPE
text/plain

IS_TEXT false

*MIME_TYPE text/plain

IS_TEXT false

See thedtdtsfile(4)man page for more information about data-type
attributes.
# Data-Typing Functionsfunctionsdata typingdata typingfunctionsdata typingfunctionsfunctionsdata typing


To look up an attribute for a data object, you must first determine the type of
the object and then ask for the appropriate attribute value for that type. The
functions that you can use to query the database for data information are
shown in. Each of these functions has a man page in section 3.
Refer to the appropriate man page for more information.
# Data-Typing Database Query Functionsdata typingdatabase query functionsdatabase query functions, data typing


`Function`

`Description`

DtDtsBufferToAttributeList

Finds the list of data attributes for a
given buffer.

DtDtsBufferToAttributeValue

Finds the data attribute for a given
buffer.

DtDtsBufferToDataType

Finds the data-type name for a given
buffer.

DtDtsDataToDataType

Finds the data type for a given set of
data.

DtDtsDataTypeIsAction

Returns the resulting saved data type for
the directory.

DtDtsDataTypeNames

Finds a complete list of available data
types.

DtDtsDataTypeToAttributeList

Finds the attribute list for a given data
attribute name.

DtDtsDataTypeToAttributeValue

Finds the attribute value for a given data
attribute name.

DtDtsFileToAttributeList

Finds the list of data attributes for a
given file.

DtDtsFileToAttributeValue

Finds the data attribute value for a given
file.

DtDtsFileToDataType

Finds the data type for a given file.

DtDtsFindAttribute

Finds the list of data types where
attributenamematchesvalue.

DtDtsFreeAttributeList

Frees the memory of the given attribute
list.

DtDtsFreeAttributeValue

Frees the memory of the given attribute
value.

DtDtsFreeDataType

Frees the application memory for the
given data-type name.

DtDtsFreeDataTypeNames

Releases memory created with theDtDtsDataTypeNamesorDtDtsFindAttributecall.

DtDtsIsTrue

A convenience function that converts a
string to a Boolean.

DtDtsRelease

Unloads the data-typing database
information, generally in preparation for
a reload.

DtDtsSetDataType

Sets the data type for the specified
directory.

DtsLoadDataTypes

Initializes and loads the database fields
for the data-typing functions. Use instead
ofDtDbLoadwhen you do not need to
use actions or action types and you need
extra performance. UseDtDbLoadwhen
you need to use actions.

You can type data and retrieve attributes in one of three ways: simple,
intermediate, or advanced.
# Simple Data Typing


The simplest way to type data is to use the following functions:

DtDtsFileToAttributeList

DtDtsFileToAttributeValue

When you use these functions, a file is typed and a single attribute, or the
entire list, is retrieved. System calls are made, data is typed, and the attribute is
retrieved. These functions call the intermediate data-typing functions.

DtDtsBufferToAttributeList

DtDtsBufferToAttributeValue

Buffers are assumed to have a mode that matches regular files that have
read/write permissions. Seeto type read-only
buffers.
# Intermediate Data Typing


When you type data and retrieve attributes, the data-typing part of the process
is the most expensive in terms of performance. You can type data in a second
way that improves performance by separating the data-typing and attribute-
retrieval functions. Use the following functions for intermediate data typing:

DtDtsBufferToDataType

DtDtsFileToDataType

DtDtsDataTypeToAttributeList

DtDtsDataTypeToAttributeValue

Use these functions if your application queries for more than a single attribute
value. When you use these functions, an object is typed and then that type is
used to retrieve one or more attributes from the attribute list.

Using the intermediate data-typing functions is the recommended way to type
data and retrieve attributes. These functions call the advanced data-typing
functions and make the same assumptions about buffers as the simpler data
typing.
# Advanced Data Typing


Advanced data typing separates system calls, data typing, and attribute
retrieval even further. Advanced data typing is more complicated to code
because it uses data from existing system calls, which are initialized in advance
and are not included as part of the data-typing function. Use the following
function for advanced data typing:

DtDtsDataToDataType

To type a read-only buffer, astatstructure should be passed that has thest_modefield set toS_IFREG | S_IROTH | S_IRGRP | S_IRUSR.
# Data Types That Are Actions (DtDtsDataTypeIsAction)


For every action in a database asynthetic data typeis generated when a
database is loaded that allows actions to be typed. These data types may have
two additional attributes:

IS_ACTIONis a string-Boolean value that tells users of this data type that it
is an action. IfIS_ACTIONis set to the stringtrue(independent of case),
the data is an action.

IS_SYNTHETICis a string-Boolean value that tells users of this data type
that it was generated from an entry in theACTIONtable. IfIS_SYNTHETICis set totrue, the data type was generated.
# Registering Objects as Drop Zonesdata typingregistering objects as drop zonesdrop zoneregistering objectsregistering objects as drop zones


If your application defines data types, follow these steps to ensure that it
provides all the drag and drop behavior that you intend:

In your application, decide if you need to define any data types.

For each data type you define, decide whether you want the associated
object to be a drop zone.

For each object that you want to register as a drop zone, decide which
operations&mdash;move, copy, or link&mdash;you want to define.

For the drop operations that are valid for each object, define the appropriate
drop actions (set theMOVE_TO_ACTION,COPY_TO_ACTION, andLINK_TO_ACTIONattributes).

If your application displays icons for data objects, you may choose to support
those icons as drop zones. If so, you need to query theMOVE_TO_ACTION,COPY_TO_ACTION, orLINK_TO_ACTIONattributes to determine the drop
behavior for those data objects. Objects should support drop operations only if
the corresponding attribute value is notNULL. If all three attributes haveNULLvalues, the object should not be registered as a drop site. Whenever you set at
least one of these attributes for an object with a defined data type, your
application registers that object as a drop zone.

When a user drags an object to a drop zone, your application determines
which gesture (that is, which drag operation) was used to make the drop.
Based on the drag operation and the drop zone's data type, the application
retrieves a drop attribute from the data-typing database. It then callsDtActionInvoke, using the following two rules to determine its parameters:

If the user drops objects A and B onto object C, callDtActionInvokewith
C, A and B as`args`. Theactionis the value of eitherMOVE_TO_ACTION,COPY_TO_ACTION,LINK_TO_ACTIONof C. If object C is an action, the args
list does not include C. Also, theactionis C.

The File Manager, along with its directory and folder objects, exemplifies how
the desktop uses the move, copy, and link drop attributes. A user can drag and
drop objects (files) to directory folders. File Manager definesMOVE_TO_ACTION,COPY_TO_ACTION, andLINK_TO_ACTIONactions for
folder objects. These actions perform the appropriate file system move, copy,
and link system functions.

See/usr/dt/appconfig/types/C/dtfile.dtfor an example of how to
define theMOVE_TO_ACTION,COPY_TO_ACTION, andLINK_TO_ACTIONattributes. See, for information
about how to use drag and drop.
# Example of Using the Data-Typing Databasedata typingcode examplecode exampledata typing


This section contains example code of how to use data typing. You can find this
example code in/usr/dt/examples/dtdts/datatyping.c. The example
code displays the data type, icon name, and supported actions for each file
passed to it. You can then use thedtactionclient to run a supported action
on the file. The usage fordatatypingis:datatyping`file1`[`file2``...`]
#include &lt;Xm/Form.h>
#include &lt;Xm/Text.h>
#include &lt;Dt/Dts.h>

#define ApplicationClass &ldquo;DtDatatyping&ldquo;

static Widget text;

static void DisplayTypeInfo(int, char**);

int main(int argc, char **argv)
{
    XtAppContext appContext;
    Widget toplevel, form;
    Arg args[20];
    int n;

    toplevel = XtAppInitialize(&amp;appContext, ApplicationClass,

 NULL,  0,
        argc, argv, NULL, NULL, 0);

    if (argc == 1) {
        printf(&ldquo;&percnt;s: No files specified.\n&ldquo;, argv[0]);
        exit(1);
    }

    form = XmCreateForm(toplevel, &ldquo;form&ldquo;, NULL, 0);
    XtManageChild(form);
    n = 0;
    XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNeditable, False); n++;
    XtSetArg(args[n], XmNeditMode, XmMULTI_LINE_EDIT); n++;
    XtSetArg(args[n], XmNrows, 25); n++;
    XtSetArg(args[n], XmNcolumns, 90); n++;
    text = XmCreateScrolledText(form, &ldquo;text&ldquo;, args, n);
    XtManageChild(text);

    XtRealizeWidget(toplevel);
 if (DtAppInitialize(appContext, XtDisplay(toplevel), toplevel,

  argv[0],
                                                ApplicationClass) == False) {
        printf(&ldquo;&percnt;s: Couldn't initialize Dt\n&ldquo;, argv[0]);
        exit(1);
    }

    DtDbLoad();

    DisplayTypeInfo(argc, argv);

    XtAppMainLoop(appContext);
}

static void DisplayTypeInfo(int argc, char **argv)
{
    char *file;
    char *datatype;
    char *icon;
    char *actions;
    char str[100];
    int i;

    sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;-20s\n&ldquo;,
                &ldquo;File&ldquo;,
                &ldquo;DataType&ldquo;,
                &ldquo;Icon&ldquo;,
                &ldquo;Actions&ldquo;);
    XmTextInsert(text, XmTextGetLastPosition(text), str);

    sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;-20s\n&ldquo;,
                &ldquo;-------------------&ldquo;,
                &ldquo;--------&ldquo;,
                &ldquo;----&ldquo;,
                &ldquo;-------&ldquo;);
    XmTextInsert(text, XmTextGetLastPosition(text), str);

      for(i=1; i &lt; argc; i++) {
        char *file = argv[i];

        /* find out the Dts data type */
        datatype = DtDtsFileToDataType(file);

        if(datatype) {
            /* find the icon attribute for the data type */
            icon = DtDtsDataTypeToAttributeValue(datatype,

   DtDTS_DA_ICON, file);
        }

  /*  Directly find the action attribute for a file */

        actions = DtDtsFileToAttributeValue(file,

   DtDTS_DA_ACTION_LIST);

        sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;s\n&ldquo;,
                        file,
                        datatype?datatype:&ldquo;unknown&ldquo;,
                        icon?icon:&ldquo;unknown&ldquo;,
                        actions?actions:&ldquo;unknown&ldquo;);
        XmTextInsert(text, XmTextGetLastPosition(text), str);

        /* Free the space allocated by Dts */

        DtDtsFreeAttributeValue(icon);
        DtDtsFreeAttributeValue(actions);
        DtDtsFreeDataType(datatype);
    }