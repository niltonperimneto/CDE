Understanding Information Manager Style Sheetsstyle sheetsunderstandingStyle sheets control the appearance of your documents in the Information
Manager browser by defining the on-line and print formatting
characteristics of every element in your DTD. Information Manager style
sheets must conform to the stylesheet document type definition,dtinfoStyle.dtd.Style sheets are specified as part of the bookcase specification
document. To build an information library with the Information Manager,
you must reference a default style sheet at the bookcase level. For more
information seedtinfoBook.dtd(5),About the Build Process and Tools,
andUsing Style Sheets.For specific information about creating style sheets see:Style Sheet StructureCreating a Style SheetStyle FeaturesStyle Sheet Structurestyle sheet structureA style sheet consists ofAutoNumberdeclarations, followed byPathstatements
and style specifications.You can specify style sheets at the bookcase, book, and section
levels. If, at a level subordinate to the bookcase level, you do
not specify a style sheet, the style for that level is inherited
from a containing element. If no style sheet is specified in a containing
element, the text appears in the Information Manager Reading Window
in 14 point Helvetica, the default as specified in the global
Xresources file. The default font for print is 12 point Helvetica.For more information on inheritance, seeUnderstanding Inheritance.Each style sheet must have a unique name within the scope of a Bookcase
document. The Information Manager uses the style sheet name as a
reference within a bookcase and within each of its books and sections.Creating a style sheet is essentially a matter of selecting
elements, via aPathstatement, by name, context, and attribute(s), and then assigning
typographic properties to thePath.You can use theSelectfeature within a path to select elements by attribute value, by
absolute position, or by relative position.You usePathstatements in the style sheet to identify the elements you wish to
format usingOnlineand/orPrint(hard copy) feature
specifications.TheOnlineandPrintfeature sets
match in function, description, and specification except for theseprint-specific features:MediumPageBreakHere is a partial example of style sheet syntax specifying
the formatting characteristics of a Chapter
element, which in some documentation is the largest element that
uses theDTINFO.Sectionarchitectural form. Specifying the largestDTINFO.Sectionas the firstPathin your style sheet is
sometimes useful for setting up default rendering characteristics.<Path>
Chapter</Path>
<online>
   <wrap word>
   <margin left=20 right=20>
   <font fallback=sans weight=medium  slant=roman size=14>
   <family name=helvetica charset="iso8859-1">
   </font>
</online>Specifying the Pathspecifying the pathA path statement specifies the hierarchical path from the
outermost containing element to an element that will be affected
by some feature you specify in the style sheet. To identify a particular
element in a given hierarchy, you simply specify the minimum unique
path to that element.A path is always resolved by the first path specification
that matches the element or element class in context. You can use
wildcard characters as well as special elementSelectstatements to identify
specific elements for formatting.Selectstatements are described inUsing
Select Statements.In the following figure, the Chapter
element contains a Title followed by two Paragraph
elements and a Section element. The Section
element, in turn, contains a Title and two Paragraph elements.
# Simple Document Hierarchy
Based on the preceding figure, the complete path for
the Section element is:<Path> Chapter Section </Path>Because the hierarchy in the diagram contains only one Section element,
the element name alone is sufficient to identify the Section element.To identify Paragraph elements contained in Section
elements, the path is:<Path>Chapter Section Paragraph </Path>Two wildcards are available for specifying paths in a style sheet:The question mark (?)
specifies that any single element can intervene.The asterisk (*)
wildcard specifies zero or any number of intervening elements.Based on the figure above, the following two statements specify
the same element:<Path> Chapter Section Title </Path><Path> Chapter ? Title </Path>However, unlike the two PATH statements above, the following PATH statement
selects more than the Title statement contained in Section.<Path> Chapter * Title </Path>Using Select Statementsselect statementsSelectstatements
enable you to apply a different style to the same element in different
contexts. For example, by using aSelectstatement, you can apply a different set of formatting characteristics
to a paragraph element depending on whether it follows a particular
type of head, is subordinated within a list, or is part of a warning.
This is possible becauseSelectstatements enable you to match specific instances of the element
either by the element's attribute value or by its position.Each element in aPathcan have its ownSelectstatement.Selectstatements
use simple comparison operators: equal to (==), not equal to (!=), and boolean operators,
"and" (&&) and "or" (||).Identifying Elements by AttributeYou can identify elements by using element attribute values.
For example, if a Paragraph element
has the following start-tag:<PARAGRAPH label="UNIque">then the path to that Paragraph element can be specified as:<PATH>Paragraph <Select>@label == "UNIque"</Select>
</PATH>Any element attribute can be used in this way by prepending
the "@" character to the attribute name. Similarly, the same
Paragraph element could be specifically
excluded with the following statement:<PATH>Paragraph <Select>@label != "UNIque"</Select>
</PATH>Identifying Elements by PositionYou can identify elements by position using models based on
the relative or absolute position of an element in the element hierarchy.
The two approaches, with their identifying keywords, are:The absolute position of elements
in the parse tree, using the"Position"keyword.The relative position of elements among like siblings,
using the"Sibling"keyword.These two models can be used together in anyPathstatement. Both require
numbers as values, but you can also use a special value,"#LAST", to specify the last element
in a list of elements. The example DTD Fragment and Document Instance
Fragments below illustrates two possible absolute and relative position
element selection models. The samplePathstatements that follow use the two models to illustrate how you
can use these selection mechanisms to select specific element items.DTD Fragment and Document Instance Fragments<!ELEMENT List - - (Title?,Item+)> 
<!ATTLIST List  Type     (Bulleted|Numbered)    "Bulleted">  
<!ELEMENT Title - - #PCDATA > 
<!ELEMENT Item  - - #PCDATA > 
INSTANCE A:                         INSTANCE B: 
<List Type="Numbered">           <List Type="Numbered"> 
<Item>Fee</item>              <Title>Fee Fie Foe Fum</item> 
<Item>Fie</item>              <Item>Fee</item> 
<Item>Foe</item>              <Item>Fie</item> 
<Item>Fum</item>              <Item>Foe</item> 
</List>                          <Item>Fum</item>                            
                                    </List>Absolute Position ModelYou can select an element based on its absolute position in
the parse tree by using the"Position"keyword inSELECTstatements.In the example DTD Fragment and Document Instance Fragments
shown above, the content model allows an optional Title element,
but in Instance A, the optional Title element is not used.
The following path identifies the first Item
element in Instance A:<PATH> List <Select>@Type == "Numbered"</Select>  Item <Select>position == 1 </Select>
</PATH>If the preceding path were used for Instance B, the Information Manager
would not find the first Item element because its absolute position in
the parse tree is second, after its peer Title.The following path selects the remaining Item elements in Instance A:<PATH> List <Select>@Type == "Numbered"</Select>  Item <Select>position != 1 </Select>
</PATH>If the preceding path were used in Instance B, all of the
Item elements would match.Relative Position ModelYou can select elements based on their position, relative
to like siblings, in the parse tree by using the"Sibling"keyword inSelectstatements. This model
provides a direct method for selecting the first and last elements
in a group of like elements.You can identify the first Item
element in either Instance A or Instance B with the following statement:<PATH> List <Select>@Type == "Numbered"</Select>   Item <Select> sibling == 1 </Select>
</PATH>The following path identifies the last Item element in both Instances:<PATH> List <Select>@Type == "Numbered"</Select>   Item <Select> sibling == "#LAST" </Select>
</PATH>Grouping Select ExpressionsYou can groupSelectexpressions to identify the elements that are neither first nor
last by using the following comparison operators:&& -- The "and" operator.
All expressions must be true.|| -- The "or" operator. Any expression can be true.Although no grouping operator is provided, the natural left-to-right
logic effects similar results. The following path shows a compoundSelectstatement for
Instance B:<PATH> List <Select>@Type == "Numbered"</Select>     Item <Select>sibling != 1 && position != "#LAST" </Select>
</PATH>As described above, the content of aSelectstatement can specify either position or attribute value. And, more
than oneSelectcan occur
in aPathstatement (one
per element name). Here are some additional guidelines regarding
the use ofSelectstatements.position ==nSelects the element if its relative position in
a string of elements is equal ton. For
exampleposition == 3selects
the element if its position is equal to 3. A space must precede
and follow the==.position !=nSelects the element if its relative position in
a string of elements isnotequal ton.
For exampleposition != 3selects the element if its position isnotequal to 3. A space must precede and follow the!=.@attribute=="string"Selects the element if itsattributeis equal tostring. For example,@label == "chapter"specifies
an element that has a label attribute with the value "chapter".
A space must precede and follow the==.@attribute!= "string"Selects the element if itsattributeisnotequal tostring.
For example,@label != "chapter"specifies an element that has a label attribute that doesnothave the value "chapter". A space must precede and follow the!=.This example specifies a title element that has a label attribute
with the value "chapter":<Path> * title <Select>@label == "chapter"</Select>
</Path>The Information Manager does not support selection on a wildcard. For example:<Path> * <Select>@label == "Chapter" </Select></Path>is not supported.Element Hierarchies and DTINFO.SectionFor style sheets, the element hierarchy defined by the source
DTD is not necessarily the only element hierarchy that requires
formatting. Each element to which theDTINFO.SectionArchitectural Form is applied constitutes the root of a separate
element hierarchy you must address. Thus, the element paths in the
figureSimple Document Hierarchyare true ifDTINFO.Sectionis applied only to the Chapter element.However, ifDTINFO.Sectionwere applied to both Chapter and Section, then the
minimum unique path for the Paragraph
elements contained in Section
elements would be:<Path> Section Paragraph
</Path>Likewise, for Paragraph elements contained in Chapter
elements, the path would be:<Path> Chapter Paragraph
</Path>Understanding InheritanceSome style sheet features are inherited from a containing
parent element. As the short example style sheet below illustrates,
child elements will display the inheritable formatting characteristics
of the parent until the style sheet specifies different formatting
characteristics for either the parent or the child. If the style
features for the parent are changed, then all of its child elements
inherit the same changes.The example style sheet showsPathstatements for the elements SECT1, SECT1 TITLE, and PARA. Note thatFont,Family,
andMarginare set in the SECT1
element and are inherited by the other elements (SECT1 TITLE and
PARA) that are contained by SECT1. In the secondPathstatement, the font size and weight values are reset to 18-point
medium for all SECT1 TITLE elements. These new values are not inherited
by the PARA element because PARA is a child of SECT1, not of SECT1
TITLE.Example Short Style Sheet<STYLESHEET Name=General>

<path>
SECT1 </path>
<Online>
   <Font Fallback=sans Weight=medium Slant=roman Size=14>
   <Family Name=helvetica Charset=iso8859-1>
   <Margin Left=20 Right=20 Top=30 Bottom=30>
</Online>

<path> SECT1 TITLE </path>
<Online>
   <Font  Weight=bold  Size=18> 
</Online>

<path>
PARA </path>
<Online>
   <Linebreak both>
   <Layout  ASpace=6  BSpace=6> 
</Online>

</STYLESHEET>The inherited style features are:FontHighLightIgnoreLayoutMarginMediumThe style features that are not inherited are:BorderCellColFormatLineBreakPageBreakPositionPrefix and SuffixRowTableTGroup