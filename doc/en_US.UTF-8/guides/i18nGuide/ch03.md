distributed internationalization
guidelinesInternationalization and Distributed NetworksThis chapter discusses tasks related to internationalization and distributed
networks.Interchange ConceptsThis section describes the way 8-bitbasic interchange
in a networkuser names and 8-bit data can benetworkscommunicated on a network for communications
utilities, such as ftp, mail, or interclient communication between the desktop
clients.There are three primarynetworksconsiderations
for communicating data:interfacesfor network communicationsSender's code set and the receiver's
code set.Whether the communications protocol allows 8-bit
data or is limited to 7-bit coded data (for example, the Japanese JUNET passes
Japanese Industrial Standard (JIS) coded data over 7-bit protocols).Type of interchange encoding available, per protocol
rules. The actual conversion needed is dependent on the specific protocol
used.If the remotecode setsnetwork
remote hosthost uses the same code set as the local
host, the following is true:If the protocol allows 8-bit
data, no conversions are needed.If the protocol allows only 7-bit data, a method
is needed to map the 8-bit code points to 7-bit ASCII values. This could
be accomplished using theiconvframework and one of the
following types of 7-bit encoded methods:Map 8-bit data as specified
in the POSIX.2 specification for uuencode and uudecode algorithms.Optionally, the 8-bit data may be mapped to a 7-bit
interchange encoding as defined by the protocol; for example, 7-bit ISO2022
in Xlib or base64 in Multipurpose Internet Message Extensions (MIME).If the remotecode setsnetwork
local hostshost's code set is different from that
of the local host, the following two cases may apply. The conversion needed
is dependent on the specific protocol used.If the protocol allows 8-bit
data, the protocol will need to specify which side does theiconvconversion and to specify the encoding on the wire. In some protocols,
an 8-bit interchange encoding is recommended that is capable of encoding
all possible code sets and identifying character repertoire.If the protocol allows only 7-bit data, a 7-bit
interchange encoding is needed, as is the identifying character repertoire.iconviconvinterfaceInterfaceIn a network environment, the code sets of the communicating systems
and the protocols of communication determine the transformation of user-specified
data so that it can be sent to the remote system in a meaningful way. The
user data (not user names) may need to be transformed from the sender's code
set to the receiver's code set, or 8-bit data may need to be transformed
into a 7-bit form to conform to protocols. A uniform interface is needed
to accomplish this.In the following examples, using theiconvinterface
is illustrated by explaining how to useiconv_open(),iconv(),andiconv_close(). To do the conversion,iconv_open()must be followed byiconv().
The terms7-bit interchangeand8-bit interchangeare used to refer to any interchange encoding used for 7-bit
and 8-bit data, respectively.Sender and Receiver Use the Same Code Sets:If the protocol allows 8-bit
data, use 8-bit data because the same code set is being used. No conversion
is needed.If the protocol allows only 7-bit data, useiconv:Sendercd = iconv_open(locale_codeset, uuencoded);Receivercd = iconv_open(&ldquo;uucode&rdquo;, locale_codeset);Sender and Receiver Use Different Code Sets:If the protocol allows 8-bit
data:Sendercd = iconv_open(locale_codeset,8-bitinterchange);Receivercd = iconv_open(8-bitinterchange, locale_codeset);If the protocol allows only 7-bit data, do the
following:Sendercd = iconv_open(locale_codeset,7-bitinterchange);Receivercd = iconv_open(7-bitinterchange, locale_codeset);Thelocale_codesetrefers to the code
set being used locally by the application. Note that while thenl_langinfo(CODESET)function may be used to obtain the
code set associated with the current locale, it is implementation-dependent
whether any conversion names match the return from thenl_langinfo(CODESET)function.The Table 3-1 outlines howiconvcan be used to perform conversions for various conditions. Specific
protocols may dictate other conversions needed.Using iconv to Perform ConversionCommunication
with system using the same code set (for example, XYZ)Communication
with system using different code sets or receiver's code set is unknownConversion to Use7-bit Protocol8-bit Protocol7-bit Protocol8-bit Protocolcode XYZInvalidBest ChoiceInvalidInvalid if remote code set is unknown7-bit Interchange ISO2022OKOKBest ChoiceOK8-bit Interchange ISO2022 ISO 10646Invalid1OKInvalidBest Choice7-bit Untagged quoted- printable
uucodeOKOKRequires code set identificationRequires code set identification8-bit Untagged base64InvalidOKRequires code set identificationRequires code set identification1Invalid means the interchange
encoding should not be used for the choice of code set and type of protocol.Stateful and Statelesscode setsstateful encodingsConversionsCodecode setsstateless encodingssets can be classified into two categories: stateful
encodings and stateless encodings.stateful and stateless encodings, conversion ofStateful EncodingsStateful encoding uses sequences of control codes, such as shift-in/shift-out,
to change character sets associated with specific code values.For instance, under compound text, the control sequence &ldquo;ESC$(B&rdquo;
can be used to indicate the start of Japanese 16-bit data in a data stream
of characters, and &ldquo;ESC(B&rdquo; can be used to indicate the end of
this double-byte character data and the start of 8-bit ASCII data. Under
this stateful encoding, the bit value 0x43 could not be interpreted without
knowing the shift state. The EBCDIC Asian code sets use shift-in/shift-out
controls to swap between double- and single- byte encodings, respectively.Converters that are written to do the conversion of stateful encodings
to other code sets tend to be a little complex due to the extra processing
needed.conversionsstateless encodingsStateless EncodingsStateless code sets are those that can be classified as one of two types:Single-byte code sets, such
as the ISO8859 familyMultibyte code sets, such as PC codes for Japanese
and Shift-JIS (SJIS)The termmultibyte code setsis also used to refer
to any code set that needs one or more bytes to encode a character; multibyte
code sets are considered stateless.Conversions are meaningful only if the code sets represent the same
character set.Simple Text Basic InterchangeWhen aconversionsstateful
code setsconversionssimple textprogram communicates data to
another program residing on a remote host, a need may arise for conversion
of data from the code set of the source machine to that of the receiver.
For example, this happens when a PC system using PC codes needs to communicate
with a workstation using an International Organization for Standardization/Extended
UNIX Code (ISO/EUC) encoding. Another example occurs when a program obtains
data in one code set but has to display this data in another code set. To
support these conversions, a standard program interface is provided based
on the XPG4iconv()function definitions.All components doing code set conversion should use theiconvfunctions as their interface to conversions. Systems are expected
to provide a wide variety of conversions, as well as a mechanism to customize
the default set of conversions.iconv Conversion Functionsiconvtext conversion functionsTheconversionsiconv textcommon method of conversions from one code set to
another is through a table-driven method. In some cases, these tables may
be too large, hence an algorithmic method may be more desirable. To accommodate
such diverse requirements, a framework is defined in XPG4 for code set conversions.
In this framework, to convert from one code set to another, open a converter,
perform the conversions, and close the converter. Theiconvfunctions
areiconv_open(),iconv(), andiconv_close().Code set converters are brought under the framework of theiconv_open(),iconv(), andiconv_close()set of functions. With these functions, it is possible to provide
and to use several different types of converters. Applications can call these
functions to convertsimple text conversion functionscharacters in one code set into characters in another
code set. With the advent of theiconvframework, converters
can be provided in a uniform manner. The access and use of these converters
is being standardized under X/Open XPG4.X Interclient (ICCCM) ConversionX interclient
(ICCCM) conversion functionsFunctionsXlibconversionsXlibprovides the following functions for doing conversions.X ICCCM Multibyte FunctionsICCCM Wide Character
FunctionsXmbTextPropertyToTextList()XwcTextPropertyToTextList()XmbTextListToTextProperty()XwcTextListToTextProperty()TheMotiflibrary does provide theXmCvtXmStringToCT()andXmCvtCtToXmString()functions; however,
these are not recommended because there are some hardcoded assumptions about
certain XmString tags. For example, if the tag isbold,XmCvtXmStringToCT()is
implementation-dependent. Across various platforms, the behavior of this function
cannot be guaranteed in all international regions.Window TitlesThe standard way fortitles for windowssetting titles is to use resources. But for applications that
set the titles of their windows directly, a localized title must be sent
to the Window Manager. Use theXCompoundTextStyleencoding
defined inXICCEncodingStyle, as well as the following
guidelines:Compoundguidelines for window titlestext can be created either
byXmbTextListToTextProperty()orXwcTextListToTextProperty().Localized titles can be displayed using theXmNtitleandXmNtitleEncodingresources of theWMShellwidget. Localized
icon names can be displayed using theXmNiconNameandXmNiconNameEncodingresources of theTopLevelShellwidget.Localized titles of dialog boxes can also be displayed
using theXmNdialogTitleresource of theXmBulletinBoardwidget.Window Manager should have an appropriate fontlist
for displaying localized strings.Following is an exampleexamples of displaying
localized title and icon nameof displaying a localized
title and icon name. Compound text is made from the compound string in this
example.include        &lt;nl_types.h>
Widget         toplevel;
Arg            al[10];
int            ac;
XTextProperty  title;
char           *localized_string;
nl_catd        fd;

XtSetLanguageProc( NULL, NULL, NULL );
fd = catopen( &ldquo;my_prog&rdquo;, 0 );
localized_string = catgets(fd, set_num, mes_num, &ldquo;defaulttitle&rdquo;);
XmbTextListToTextProperty( XtDisplay(toplevel), &amp;localized_string,
       1, XCompoundTextStyle, &amp;title);
ac = 0;
XtSetArg(al[ac], XmNtitle, title.value); ac++;
XtSetArg(al[ac], XmNtitleEncoding, title.encoding); ac++;
XtSetValues(toplevel, al, ac);If you are using a window rather than widgets, theXmbSetWMProperties()function automatically converts a localized
string into the properXICCEncodingStyle.Mail Basic InterchangeIn general, electronic mail (email) strategy has been one of turning
email into a canonical, labeled format as opposed to optimizing a message
given knowledge of the receiver's locale. This means that in the email world,
you should always assume that the receivermaybe in
a different locale. In the desktop world, the default email transport is
Simple Mail Transfer Protocol (SMTP), which only supports 7-bit transmission
channels.With this understanding, the email strategy for the desktop is as follows:The sending agents, by default
(unless instructed otherwise by the user), converts a body part into astandardformat for the sending transmission channel and labels
the body part with the character encoding used.The receiving agent looks at the body part to see
if it can support the character encoding; if it can, it converts it into
the local character set.In addition, because the MIME format is used for messages, any 8-bit
to 7-bit transformations are done using the built-in MIME transport encodings
(base64 or quoted-printable). See the Request for Comments (RFC) 1521 MIME
standard specification.Encodings and Code SetsToencodingsunderstand code
sets, it is necessary to first understand character sets. Acharacter
setis a collection of predefined characters based on the specific
needs of one or more languages without regard to the encoding values used
to represent the characters. The choice of which code set to use depends
on the user's data processing requirements. A particular character set can
be encoded using different encoding schemes. For example, the ASCII character
set defines the set of characters found in the English language. The Japanese
Industrial Standard (JIS) character set defines the set of characters used
in the Japanese language. Both the English and Japanese character sets can
be encoded using different code sets.The ISO2022 standard defines a coded character set as a group of precise
rules that defines a character set and the one-to-one relationship between
each character and its bit pattern. A code set defines the bit patterns that
the system uses to identify characters.Acode pagecode page is similar
to a code set with the limitation that a code-page specification is based
on a 16-column by 16-row matrix. The intersection of each column and row
defines a coded character.code setsstrategyCode Set StrategyThe common open software environment code set support is based on International
Organization for Standardization (ISO) and industry-standard code sets providing
industry-standard code sets that satisfy the data processing needs of users.Each locale in the system defines which code set it uses and how the
characters within the code set are manipulated. Because multiple locales
can be installed on the system, multiple code sets can be used by different
users on the system. While the system can be configured with locales using
different code sets, all system utilities assume that the system is running
under a single code set.Most commands have no knowledge of the underlying code set being used
by the locale. The knowledge of code sets is hidden by the code-set-independent
library subroutines (Internationalization libraries), which pass information
to the code-set-dependent subroutines.Because many programs rely on ASCII, all code sets include the 7-bit
ASCII code set as a proper subset. Because the 7-bit ASCII code set is common
to all supported code sets, its characters are sometimes referred to as theportablecharacter set.The 7-bit ASCII code set is based on the ISO646 definition and contains
the control characters, punctuation characters, digits (0-9), and the English
alphabet in uppercase and lowercase.code setsstructureCode Set StructureEach code set is divided into two principle areas:Graphic Left (GL) Columns 0-7Graphic Right (GR) Columns 8-FThe first two columns of each code set are reserved by ISO standards
for control characters. The terms C0 and C1 are used to denote the control
characters for the Graphic Left and Graphic Right areas, respectively.The PC code sets use the C1 control area to encode graphic characters.The remaining six columns are used to encode graphic characters (see).
Graphic characters are considered to be printable characters, while the control
characters are used by devices and applications to indicate some special
functionCode Set OverviewControl CharactersBased on the ISOcode setscontrol charactersdefinition, a control character
initiates, modifies, or stops a control operation. A control character is
not a graphic character, but can have graphic representation in some instances.
The control characters in the ISO646- IRV character set are present in all
supported code sets, and the encoded values of the C0 control characters
are consistent throughout the code sets.Graphic CharactersEachcode setsgraphic characterscode set can be considered to be divided into one
or more character sets, such that each character is given a unique coded
value. The ISO standard reserves six columns for encoding characters and
does not allow graphic characters to be encoded in the control character
columns.Single-Byte Code SetsCode setscode setssingle-bytethat use all 8 bits of a byte can support European,
Middle Eastern, and other alphabetic languages. Such code sets are called
single-byte code sets. This provides a limit of encoding 191 characters,
not including control characters.Multibyte Code Setscode setsmultibyteThe termmultibyte code setsis used to refer to
all possible code sets regardless of the number of bytes needed to encode
any specific character. Because the operating system should be capable of
supporting any number of bits to encode a character, a multibyte code set
may contain characters that are encoded with 8, 16, 32, or more bits. Even
single-byte code sets are considered to be multibyte code sets.Extended UNIX Code (EUC)code setsextended UNIX code (EUC)Code SetThe EUC code set uses control characters to identify characters in some
of the character sets. The encoding rules are based on the ISO2022 definition
for the encoding of 7-bit and 8-bit data. The EUC code set uses control characters
to separate some of the character sets.The term EUC denotes these general encoding rules. A code set based
on EUC conforms to the EUC encoding rules but also identifies the specific
character sets associated with the specific instances. For example, eucJP
for Japanese refers to the encoding of the JIS characters according to the
EUC encoding rules.The first set (CS0) always contains an ISO646 character set. All of
the other sets must have the most-significant bit (MSB) set to 1, and they
can use any number of bytes to encode the characters. In addition, all characters
within a set must have:Same number of bytes to encode
all charactersSame column display width (number of columns on
a fixed-width terminal)Each character in the third set (CS2) is always preceded with the control
character SS2 (single-shift 2, 0x8e). Code sets that conform to EUC do not
use the SS2 control character other than to identify the third set.Each character in the fourth set (CS3) is always preceded with the control
character SS3 (single-shift 3, 0x8f). Code sets that conform to EUC do not
use the SS3 control character other than to identify the fourth set.ISO EUC Code SetsThe followingcode setsISO
EUCcode setsISO EUC code setare based on definitions set by the International Organization
for Standardization (ISO).ISO646-IRVISO8859-1ISO8859-xeucJPeucTWeucKRISO646-IRVTheISO646-IRV code setISO646-IRV
code setcode setsISO646-IRV, descriptiondefines the code set used for information processing
based on a 7-bit encoding. The character set associated with this code set
is derived from the ASCII characters.ISO8859-1ISO8859-1ISO8859-1 code setcode setsISO8859-1, descriptionencoding is a single-byte encoding that is based on and is compatible
with other ISO, American National Standards Institute (ANSI), and European
Computer Manufacturer's Association (ECMA) code extension techniques. The
ISO8859 encoding defines a family of code sets with each member containing
its own unique character sets. The 7-bit ASCII code set is a proper subset
of each of the code sets in the ISO8859 family.The ISO8859-1 code set is called the ISO Latin-1 code set and consists
of two character sets:ISO646-IRV Graphic Left, 7-bit
ASCII character setISO8859-1 Graphic Right (Latin) character setThese character sets combined include the characters necessary for Western
European languages such as Danish, Dutch, English, Finnish, French, German,
Icelandic, Italian, Norwegian, Portuguese, Spanish, and Swedish.While the ASCII code set defines an order for the English alphabet,
the Graphic Right (GR) characters are not ordered according to any specific
language. The language-specific ordering is defined by the locale.Other ISO8859code setsISO8859,
list of otherCode SetsThis section lists theISO8859, other significant
code setsother significant ISO8859 code sets. Each code
set includes the ASCII character set plus its own unique characters.ISO8859-2Latin alphabet, No. 2, Eastern EuropeAlbanianCzechoslovakianEnglishGermanHungarianPolishRumanianSerbo-CroatianSlovakSloveneISO8859-5Latin/Cyrillic alphabetBulgarianByelorussianEnglishMacedonianRussianUkrainianISO8859-6Latin/Arabic alphabetEnglishArabicISO8859-7Latin/Greek alphabetEnglishGreekISO8859-8Latin/Hebrew alphabetEnglishHebrewISO8859-9Latin/Turkish alphabetDanishDutchEnglishFinnishFrenchGermanIrishItalianNorwegianPortugueseSpanishSwedishTurkisheucJPTheeucJP code setEUCcode setseucJP,
descriptionfor Japanese consists of single-byte and
multibyte characters (2 and 3 bytes). The encoding conforms to ISO2022 and
is based on JIS and EUC definitions, see.Encoding for eucJP`CS`EncodingCharacter Setcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxJIS X0208-1990cs20x8E1xxxxxxxJIS X0201-1976cs30x8F1xxxxxxx 1xxxxxxxJIS X0212-1990JIS X0208-1990A code of the Japanese graphic character set for information interchange
(1990 version) that contains 147 special characters, 10 numeric digits, 83
Hiragana characters, 86 Katakana characters, 52 Latin characters, 48 Greek
characters, 66 Cyrillic characters, 32 line-drawing elements, and 6355 Kanji
characters.JIS X0201A code for information interchange that contains 63 Katakana characters.JIS X0212-1990A code of the supplementary Japanese graphic character set for information
interchange (1990 version) that contains 21 additional special characters,
21 additional Greek characters, 26 additional Cyrillic characters, 27 additional
Latin characters, 171 Latin characters with diacritical marks, and 5801
additional Kanji characters.eucTWThe EUCcode setseucTW, descriptionforeucTW code setTraditional Chinese is an encoding consisting
of characters that contain single-byte and multibyte (2 and 4 bytes) characters.
The EUC encoding conforms to ISO2022 and is based on the Chinese National
Standard (CNS) as defined by the Republic of China and the EUC definition,
see.Encoding for eucTW`CS`EncodingCharacter Setcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxCNS 11643.1992 - plane 1cs20x8EA21xxxxxxx1xxxxxxxCNS 11643.1992 - plane 2cs30x8EA31xxxxxxx1xxxxxxxCNS 11643.1992 - plane 30x8EB01xxxxxxx1xxxxxxxCNS 11643.1992 - Plane 16CNS 11643-1992 defines 16 planes for the Chinese Standard Interchange
Code, each plane can support up to 8836 characters (94x94). Currently, only
planes 1 through 7 have characters assigned.CNS character definitionsshows the 16 planes
of the CNS 11643-1992 standard.16 Planes of the CNS 11643-1992 StandardPlaneDefinition# of CharacterEUC Encoding1Most frequently used6085A1A1-FDCB2Secondary frequently76508EA2 A1A1 - 8EA2 F2C43Exec.Yuen EDP1center61488EA3 A1A1 - 8EA3 E2C64RIS2, Vendor
defined72988EA4 A1A1 - 8EA4 EEDC5Rarely used by MOE386038EA5 A1A1 - 8EA5 FCD16Variation char set 1 by MOE63888EA6 A1A1 - 8EA6 E4FA7Variation char set 2 by MOE65398EA7 A1A1 - 8EA7 E6D58Undefined08EA8 A1A1 - 8EA8 FEFE9Undefined08EA9 A1A1 - 8EA9 FEFE10Undefined08EAA A1A1 - 8EAA FEFE11Undefined08EAB A1A1 - 8EAB FEFE12User Defined Character (UDC)08EAC A1A1 - 8EAC FEFE13UDC08EAD A1A1 - 9EAD FEFE14UDC08EAE A1A1 - 8EAE FEFE15UDC08EAF A1A1 - 8EAF FEFE16UDC08EB0 A1A1 - 8EB0 FEFE1EDP: Center of Directorate, General of Budget, Accounting, and Statistics2RIS: Residence Information System3MOE: Ministry of EducationeucKRThe EUCcode setseucKR, descriptionfor Korean iseucKR code setan encoding consisting of single-byte and multibyte
characters (shown in). The encoding conforms
to ISO2022 and is based on Korean Standard Code (KSC) set and EUC definitions.Encoding for eucKR.`CS`EncodingCharacter
Setcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxKS C 5601-1992cs2Not usedcs3Not usedKSC 5601-1992 (code of the Korean character set for information interchange,
1992 version) contains 432 special characters, 30 Arabic and Roman numeral
characters, 94 Hangul alphabet characters, 52 Roman characters, 48 Greek
characters, 27 Latin characters, 169 Japanese characters, 66 Russian characters,
68 line-drawing elements, 2344 precomposed Hangul characters, and 4888 Hanja
characters.The Hangul characters represent the sounds of the Korean words. Each
Hangul character is composed of from one to three of the Hangul elementary
phonetic signs: an initial consonant (if any), a vowel, and a final consonant
(if any). Many Korean words can also be written with Traditional Chinese
characters (called Hanja in Korean). In traditional times, Korean texts were
generally written in a mixture of Hangul and Hanja: Hanja for the main words
(nouns, verbs, modifiers) and Hangul for the particles and grammatical inflections.
In recent times, most Korean texts are written purely in Hangul, although
personal names may still appear written with Hanja.