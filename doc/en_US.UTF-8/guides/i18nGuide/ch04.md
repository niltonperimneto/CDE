Xt, Xlib, and Motif DependenciesFor information on Xt and Xlib dependencies, refer to Chapter 13 ofXlib &mdash; C Language Interface.The rest of this chapter discusses tasks related to internationalizing
with Motif.Locale Managementlanguage
environmentdescriptionenvironment, languageThe termlanguage environmentrefers to the set
of localized data that the application needs to run correctly in the user-specified
locale. A language environment supplies the rules associated with a specific
language. In addition, the language environment consists of any externally
stored data, such as localized strings or text used by the application. For
example, the menu items displayed by an application might be stored in separate
files for each language supported by the application. This type of data can
be stored in resource files, User Interface Definition (UID) files, or message
catalogs (on XPG3-compliant systems).A single language environment is established when an application runs.
The language environment in which an application operates is specified by
the application user, often either by setting an environment variable (LANGorLC_*on POSIX-based systems)
or by setting the xnlLanguage resource. The application then sets the language
environment based on the user's specification. The application can do this
by using thesetlocale()function in a language
procedure established by theXtSetLanguageProc()function. This causes Xt to cache a per-display language string that is used
by theXtResolvePathname()function to find
resource, bitmap, and User Interface Language (UIL) files.An application that supplies a language procedure can either provide
its own procedure or use an Xtlanguage proceduredefault procedure. In either case, the application establishes
the language procedure by calling theXtSetLanguageProc()function before initializing the toolkit and before loading
the resource databases (such as by calling theXtAppInitialize()function). When a language procedure is installed, Xt calls
it in the process of constructing the initial resource database. Xt uses
the value returned by the language procedure as its per-display language
string.The default language procedure performs the following tasks:Sets the locale. This is done
by using:setlocale(LC_ALL,language);wherelanguageis the value of thexnlLanguageresource, or the empty string (&ldquo;&rdquo;) if
thexnlLanguageresource is not set. When thexnlLanguageresource is not set, the locale is generally derived
from an environment variable (LANGon POSIX-based
systems).Calls theXSupportsLocale()function to verify that the locale just set is supported. If not, a warning
message is issued and the locale is set to C.Calls theXSetLocaleModifiers()function specifying the empty string.Returns the value of the current locale. On ANSI
C-based systems, this is the result of calling:setlocale(LC_ALL, NULL);The application can use the default language procedure by making the
call to theXtSetLanguageProc()function
in the following manner:XtSetLanguageProc(NULL, NULL, NULL);
...
toplevel = XtAppInitialize(...);By default, Xt does not install any language procedure. If the application
does not call theXtSetLanguageProc()function,
Xt uses as its per-display language string the value of thexnlLanguageresource if it is set. If thexnlLanguageresource is not set, Xt derives the language string from theLANGenvironment variable.XtSetLanguageProcdefault languageThe per-display language string that results from this process is implementation-dependent,
and Xt provides no public means of examining the language string once it
is established.By supplying its own language procedure, an application can use any
procedure it wants for setting the language string.Font ManagementThe desktop uses render tables to display text. A render table is a tagged
collection of renditions, each of which specifies the data used in rendering
compound strings. For information on renditions, and render tables, refer
to &MotifProgGd;.Drawing Localized Textcompound
stringsfor international text displaycompound stringsstructures, interaction with
render tablesA compound string (typeXmString)is a means of
encoding text so that it can be displayed in many different fonts without
changing anything in the program. A rendition, which is identified by a rendition
tag, specifies the font (and other characteristics, such as color) with which
the compound string with that rendition tag is to be rendered.Especially useful for internationalization purposes are render tables,
which are collections of renditions. Among the renditions in the table may
be one tagged_MOTIF_DEFAULT_LOCALE,
which is the rendition used for the current locale. For internationalized
applications, render tables should be specified in resource files.The foregoing discussion provides only a brief overview of some subjects
related to drawing localized text; for complete information, refer to &MotifProgGd;.Inputting Localized TextVendorShell widget classas input managerinput methodVendorShell widget classVendorShell widget classgeometry managementIn the system environment, theVendorShellwidget class is enhanced to provide the interface to the input method. While
the VendorShell class controls only one child widget in its geometry management,
an extension has been added to the VendorShell class to enhance it for managing
all components necessary in the interface to an input method. These components
include the status area, preedit area, and the MainWindow area.VendorShell widget classmanaging componentsstatus areaVendorShell widget classmanaging componentspreedit areaVendorShell
widget classmanaging componentsMainWindow areaWhen the input method requires a status area or a preedit area or both,
theVendorShellwidget automatically instantiates
the status and preedit areas and manages their geometry layout. Any status
area or preedit area is managed by theVendorShellwidget internally and is not accessible by the client. The widget
instantiated as the child of theVendorShellwidget is called the MainWindow area.input methodrequirementsinternational
text inputinput methodsinput methodinternational text inputThe input method to be used by theVendorShellwidget is determined by theXmNinputMethodresource;
for example,@im=alt. The default value of
Null indicates to choose the default input method associated with the locale
at the time that VendorShell is created. As such, the user can affect which
input method is selected by either setting the locale, setting theXmNinputMethodresource, or setting both. The locale name is
concatenated with theXmNinputMethodresource to
determine the input method name. The locale name must not be specified in
this resource. The modifier name for theXmNinputMethodresource needs to be in the form@im=modifier, where modifier is the string used to qualify
which input method is selected.input methoddetermining, XmNinputMethod resourceXmNinputMethod resource, determining input methodTheVendorShellwidget can support
multiple widgets that can share the input method. Yet only one widget can
have the keyboard focus (for example, receive key press events and send them
to an input method) at any given time. To support multiple widgets (such
asTextwidgets), the widgets need to be
descendants of theVendorShellwidget.TheVendorShellwidget class is a superclass
of theTransientShellandTopLevelShellwidget classes. As such, an instantiation
of aTopLevelShellor aDialogShellis essentially an instantiation of aVendorShellwidget class.TheVendorShellwidget behaves as an
input manager only if one of its descendants is anXmText[Field]instance. As soon as anXmText[Field]instance is created as a descendant of theVendorShellwidget,VendorShellcreates the necessary
areas required by the particular input methods dictated by the current locale.
Even if anXmText[Field]instance is not
mapped but just created, VendorShell has the geometry management behavior
as described previously.AVendorShellwidget does the following:international text inputVendorShell widget operationsEnables applications to process
multibyte character input and output that is supported by the locales installed
in the system.VendorShell widget operationsprocessing multibyte character I/OManages an input method instance as defined in
theXmImreference functions.Supports preediting within a preedit area in either
OnTheSpot, OffTheSpot, OverTheSpot, Root, or None mode. Localized text can be entered
into anyTextchild widget in a multipleTextchildren widget tree by changing the focus.Provides geometry management for descendant child
widgets.Input method interactions may also be customized by users through a
dialog box that is invoked from the Style Manager application. Refer to theCDE User's Guidefor more information.Geometry Managementinternational text inputgeometry managementgeometry managementinternational text inputTheVendorShellwidget provides geometry
management and focus management for the input method's user interface components,
as necessary. If the locale warrants it (for example, if the locale is a
Japanese Extended UNIX Code (EUC) locale), theVendorShellwidget automatically allocates and manages the geometry
of any required preedit area or status area or both.Depending on the current preediting being done, an auxiliary area may
be required. If so, theVendorShellwidget
also instantiates and manages the auxiliary area. Typically, the child of
theVendorShellwidget is a container widget
(such as theXmBulletinBoardorXmRowColumnwidgets) that can manage
multipleTextandTextFieldwidgets, which allow multibyte character
input from the user. In this scenario, allTextwidgets share the same input method.geometry managementXmBulletinBoard
widgetgeometry managementXmRowColumn widgetgeometry managementText widgetgeometry managementTextField widgetinternational text inputmultibyte charactersinput methodText widgetText widgets, input methodThe status, preedit, and auxiliary
areas are not accessible to the application programmer. For example, it is
not intended for the application programmer to access the window ID of the
status area. The user does not need to worry about the instantiation or management
of these components as they are managed as required by theVendorShellwidget class.The application programmer has some control over the behavior of the
input method user interface components throughXmNpreeditTyperesources of theVendorShellwidget class.geometry managementapplication programmer controlsapplication programmer, controlling input method components(TheOffTheSpot,OnTheSpot, andOverTheSpotmodes are described elsewhere in this manual).Geometry management extends to all input method user interface components.
When the application program window (aTopLevelShellwidget) is resized, the input method user interface components are resized
accordingly, and the preedited strings in them are rearranged as required.
Of course, this assumes that the shell window has a resize policy of True.When theVendorShellwidget is created,
if a specific input method requires a status area, preedit area, or both,
the size of the VendorShell considers the areas required by these components.
The extra areas required by the preedit and status areas are part of theVendorShellwidget's area. They are also
managed by theVendorShellwidget, if resizing
is necessary.Because of the potential instantiation of these areas (status and preedit),
depending on the input method currently being used, the size of theVendorShellwidget area does not necessarily grow or shrink
to accommodate exactly the size of its child. The size of theVendorShellwidget area grows or shrinks to accommodate
both its child's geometryandthe geometry of these
input method user interface areas. There may be a difference (for example,
of 20 pixels) in height between theVendorShellwidget and its child widget (the MainWindow area). The width geometry isnotaffected by the input method user interface
components.VendorShell widget classsizeVendorShell widget classchild widget sizeIn summary, the requested size of the child is honored if possible;
the actual size of theVendorShellmay be
larger than its child.The requests to specify the geometry of theVendorShellwidget and its child are honored as long as they do not
conflict with each other or are within the constraint of theVendorShellwidget's ability to resize. When they do conflict,
the child's widget geometry request has higher precedence. For example, if
the size of the child widget is specified as 100x100, the size of VendorShell
is also specified as 100x100. The resulting VendorShell has a size of 100x120,
while its child widget gets a size of 100x100. If the size of the child widget
is not specified, the VendorShell shrinks its child widget if necessary to
honor its own size specification. For example, if the size of VendorShell
is specified as 100x100 and no size is specified for its child, the child
widget has a size of 100x80. If theVendorShellwidget is disabled from resizing, regardless of what the geometry
request of its child is, theVendorShellwidget honors only its own geometry specification.Focus Managementinternational text inputfocus managementVendorShell
widget classfocus managementfocus managementinternational text inputLanguages with large numbers of characters (such as Japanese and Chinese)
require an input method that allows the user to compose characters in that
language interactively.input methodmultibyte charactersThis is because, for these languages,
there are many more characters than can be reasonably mapped to a terminal
keyboard.The interactive process of composing characters in such languages is
calledpreediting. The preediting itself is handled
by the input method. However, the user interface of the preediting is determined
by the system environment. An interface needs to exist between the input
method and the system environment. This is done through theVendorShellwidget of the system environment.preeditingVendorShell
widget classas interfaceinterfacesbetween input method and Common Desktop Environmentinput methodCommon Desktop
Environment interfaceCommon Desktop
Environmentinput method interfacepreeditingillustrates a case with Japanese preediting. The
string shown in reverse video is the string in preediting. This string can
be moved across different windows by giving focus to the particular window.
However, only one preediting session can occur at one time.Japanese preediting exampleFor an example of focus management, suppose aTopLevelShellwidget (a subclass of theVendorShellwidget) has anXmBulletinBoardwidget child
(MainWindow area), which has fiveXmTextwidgets as children. Assume the locale requires the preedit area, and assume
the OverTheSpot mode is specified. Because theVendorShellwidget manages only one instance of an input method, you
can run only one preedit area at a time inside theTopLevelShellwidget. If the focus is moved from oneTextwidget to another, the current preedit string under
construction is also moved on top of theTextwidget that currently has focus. Processing of keys to the oldTextwidget is suspended temporarily. Subsequent interface
of the input method, such as the delivery of the string at preedit completion,
is made to the new, focusedTextwidget.focus managementexample descriptionThe string being preedited can be moved to the location of the focus;
for example, by clicking the mouse.A string that the end user is finished preediting and that is already
confirmedcannotbe reconverted. Once the string is
composed, it is committed. Refer to Chapter 11 of &MotifProgGd; for information
on actions that cause a preedit string to be committed.Internationalized User Interface LanguageNational Language SupportUser Interface Language
(UIL)User Interface Language
(UIL), see UIL <$nopage>The capability to parse a multibyte character string as a string literal
has been added to the User Interface Language (UIL).programming for international useUILparsing multibyte character stringCreation of a UIL
file is performed by using the characteristics of the target language and
writing the User Interface Definition (UID) file.Programming for Internationalized User Interface LanguagelocalesUIL compilerThe UIL compiler parses nonstandard charsets as locale text. This requires
the UIL compiler to be run in the same locale as any locale text.programming for international useUILparsing nonstandard charsetsprogramming for international useUILlocale textIf the locale text of a widget requires a font set (more than one font),
the fonts must be specified within the resource file as a render table.To use a specific language with UIL, a UIL file is written according
to characteristics of the target language and compiled into a UID file. The
UIL file that contains localized text needs to be compiled in the locale
in which it is to run.String Literalsprogramming for international useUILstring literalsstring literalsprogramming for international
UILThe following shows examples of literal strings. The cur_charset value
is always set to the default_charset value, which allows the string literal
to contain locale text.To set locale text in the string literal with the default_charset value,
enter the following:XmNlabelString = 'XXXXXX';ORXmNlabelString = #default_charset&ldquo;XXXXXX&rdquo;;Compile the UIL file with theLANGenvironment
variable matching the encoding of the locale text. Otherwise, the string
literal is not compiled properly.Fontfont setsprogramming
for international UILSetsprogramming
for international useUILprogramming for international UILfont setsprogramming for international UILThe font set cannot be set through UIL source programming. Whenever
the font set is required, you must set it in the resource file as render
table resource. Refer to &MotifProgGd; for more information.Font Listsfont lists in UIL, specifying resources
forLike font sets, font lists are specified in resource files as render
tables. Refer to &MotifProgGd; for detailed information.Render Tablesrender tables in UIL, specifying resources
forRender tables, as well as renditions, tab lists,
and tab stops, are implemented as a special class of objects.
Refer to &MotifProgGd; for detailed information.Creatingresource filescreating
for international UILResource Filesprogramming for international useUILprogramming for international UILresource files, creatingresource filescreating for international UILIf necessary, set the input method-related resources in the resource
file as shown in the following example:*preeditType: OverTheSpot, OnTheSpot, OffTheSpot, Root, or NoneSetting thesetting the environmentfor international UILEnvironmentprogramming for international useUILprogramming for international UILsetting the environmentfor international UILFor a locale-sensitive application, set the UID file to the appropriate
directory. Set theUIDPATHorXAPPLRESDIRenvironment variable to the appropriate value.For example, to run theuil_sampleprogram with an English environment (LANGenvironment
variable isen_US), setuil_sample.uidwith Latin characters at the$HOME/en_USdirectory, or setuil_sample.uidto a directory and
set theUIDPATHenvironment variable to the full
path name of theuil_sample.uidfile.To run theuil_sampleprogram with
a Japanese environment (LANGenvironment variable
isja_JP), create auil_sample.uidfile with Japanese (multibyte) characters at the$HOME/ja_JPdirectory, or placeuil_sample.uidto a unique directory
and set theUIDPATHenvironment variable to the
full path name of theuil_sample.uidfile. The following
list specifies the possible variables:%USpecifies the UID file string.%NSpecifies the class name of the application.%LSpecifies the value of thexnlLanguageresource orLC_CTYPEcategory.%lSpecifies the language component of thexnlLanguageresource or theLC_CTYPEcategory.If theXAPPLRESDIRenvironment variable is
set, theMrmOpenHierarchy()function searches
the UID file in the following order:setting the environmentsearching the UID fileUID file searchMrmOpenHierarchy
function, searching UID fileUID
file searchUID file path name$UIDPATH%U$XAPPLRESDIR/%L/uid/%N/%U$XAPPLRESDIR/%l/uid/%N/%U$XAPPLRESDIR/uid/%N/%U$XAPPLRESDIR/%L/uid/%U$XAPPLRESDIR/%l/uid/%U$XAPPLRESDIR/uid/%U$HOME/uid/%U$HOME/%U/usr/lib/X11/%L/uid/%N/%U/usr/lib/X11/%l/uid/%N/%U/usr/lib/X11/uid/%N/%U/usr/lib/X11/%L/uid/%U/usr/lib/X11/%l/uid/%U/usr/lib/X11/uid/%U/usr/include/X11/uid/%UIf theXAPPLRESDIRenvironment variable is
not set, theMrmOpenHierarchy()function
uses$HOMEinstead of theXAPPLRESDIRenvironment variable.default_charset Character Set in UILUser Interface
Language (UIL), see UIL <$nopage>default_charset string literalstring literalsdefault_charset in UILdefault_charset
string literalWith the default_charset string literal, any characters can be set as
a valid string literal. For example, if theLANGenvironment variable isel_GR, the string
literal with default_charset can contain any Greek character. If theLANGenvironment variable isja_JP,
the default_charset string literal can contain any Japanese character encoded
in Japanese EUC.If no character set is set to a string literal, the character set of
the string literal is set as cur_charset. And, in the system environment,
the cur_charset value is always set as default_charset.ExampleUIL (User Interface Language)sample Japanese and English program: uil_sampleshows a UIL sample program on English and Japanese
environments.Sample UIL program on English and Japanese environmentsIn the following sample program,LLLindicates
locale text, which can be Japanese, Korean, Traditional Chinese, Greek, French,
or others.uil_sample.uil
!
!  sample uil file - uil_sample.uil
!
!   C source file - uil_sample.c
!
!    Resource file - uil-sample.resource
!
module Test
  version = 'v1.0'
  names = case_sensitive
  objects = {
   XmPushButton = gadget;
  }
!************************************
!  declare callback procedure
!************************************
procedure
  exit_CB;
!***************************************************************
!  declare BulletinBoard as parent of PushButton and Text
!***************************************************************
object
  bb: XmBulletinBoard {
     arguments{
      XmNwidth = 500;
      XmNheight = 200;
     };
     controls{
      XmPushButton    pb1;
      XmText   text1;
     };
  };
!****************************
!  declare PushButton
!****************************
object
  pb1: XmPushButton {
     arguments{
       XmNlabelString = #Normal &ldquo;LLLexit buttonLLL&rdquo;;
       XmNx = 50;
       XmNy = 50;
     };
     callbacks{
       XmNactivateCallback = procedure exit_CB;
     };
  };
!*********************
!  declare Text
!*********************
  text1: XmText {
     arguments{
     XmNx = 50;
     XmNy = 150;
   };
  };
end module;
*
*   C source file - uil_sample.c
*
*/
#include &lt;Mrm/MrmAppl.h>
#include &lt;locale.h>
void exit_CB();
static   MrmHierarchy    hierarchy;
static   MrmType   *class;

/******************************************/
/*  specify the UID hierarchy list         */
/*****************************************/
static   char   *aray_file[]=
     {&ldquo;uil_sample.uid&rdquo;
     };
static   int  num_file = (sizeof aray_file / sizeof
aray_file[0]);
/******************************************************/
/*  define the mapping between UIL procedure names            */
/*  and their addresses            */

/******************************************************/
static   MRMRegisterArg    reglist[]={
     {&ldquo;exit_CB&rdquo;,(caddr_t) exit_CB}Compound Strings in UILcompound stringsin UILThree mechanisms exist for specifying strings in UIL files:As string literals, which may
be stored in UID files as either null-terminated strings or compound stringsAs compound stringsAs wide character stringsBoth string literals and compound strings consist of text, a character
set, and a writing direction. For string literals and for compound strings
with no explicit direction, UIL infers the writing direction from the character
set. The UIL concatenation operator (&) concatenates both string literals
and compound strings.Regardless of whether UIL stores string literals in UID files as null-terminated
strings or as compoundstring literalsin UID filesstrings, it stores information about
each string's character set and writing direction along with the text. In
general, UIL stores string literals or string expressions as compound strings
in UID files under the following conditions:When a string expression consists
of two or more literals with different character sets or writing directionsWhen the literal or expression is used as a value
that has a compound string data type (such as the value of a resource whose
data type is compound string)UIL recognizes a number of keywords specifying character sets. UIL associates
parsingcharacter set keywordscharacter sets, defining with UIL CHARACTER_SET functionstring literalssyntaxrules, including parsing direction and whether characters
have 8 or 16 bits, for each character set it recognizes. It is also possible
to define a character set using the UILCHARACTER_SETfunction.The syntax of a string literal is one of the following:'[character_string]'[#char_set]&ldquo;[character_string]&rdquo;For each syntax, the character set of the string is determined as follows:For a string declared as 'character_string', the character set is the code set component of
theLANGenvironment variable, if it is set in the
UIL compilation environment; or it is the value ofXmFALLBACK_CHARSETif theLANGenvironment variable
is not set or has no code set. By default, the value ofXmFALLBACK_CHARSETis ISO8859-1, but vendors may supply
different values.For a string declared as#char_set&ldquo;string&rdquo;, the character set ischar_set.For a string declared as&ldquo;character_string&rdquo;, the character set depends on whether
the module has aCHARACTER_SETclause and whether the
UIL compiler'suse_setlocale_flagis set.If the module has aCHARACTER_SETclause, the character set is the one specified in
that clause.If the module has noCHARACTER_SETclause but theuilcommand was started with the-soption, or if theUil()function
was started withuse_setlocale_flag set, UIL calls thesetlocale()function and parses the string
in the current locale. The character set of the resulting string isXmFONTLIST_DEFAULT_TAG.If the module has noCHARACTER_SETclause and theuilcommand was started without
the-soption, or if theUil()function was started withoutuse_setlocale_flag, the character set is the code set component of theLANGenvironment variable, if it is set in the UIL compilation
environment, or the character set is the value ofXmFALLBACK_CHARSETifLANGis not set or has no code
set.UIL always stores a string specified using theCOMPOUND_STRINGfunction as a compound string. This function takes as arguments
a string expression and optional specifications of a character set, direction,
and whether to append a separator to the string. If no character set or direction
is specified, UIL derives it from the string expression, as described in
the preceding section.Certain predefined escape sequences, beginning with a \ (backslash),
may be displayed in string literals, with the following exceptions: &ndash;
A string in single quotation marks can span multiple lines, with each
new line character escaped by a backslash. A string in double quotation
marks cannot span multiple lines. &ndash; Escape sequences are processed
literally inside a string that is parsed in the current locale (a localized
string).