A Complex Scriptscript, complexThis chapter describes a much more complex script than that described
in Chapter 2. Because of its length, the entire script is listed in Appendix
C. Remember that this guide is not a tutorial on KornShell programming.
If you are not familiar with KornShell programming, you should obtain a
book on the subject and have it handy for reference.Using script_findThe script,script_findscript_find, demonstrates how you can usedtkshto provide a graphical interface to thefindcommand.script_findproduces a window within which you can
specify parameters for thefindcommand. To fully understand
the script, you should be familiar with thefindcommand
and you should have its man page available. A number of the toggle button
menu choices in the window produced byscript_findrequire
some knowledge of thefindcommand.The script's window allows you to specify a search directory and a file
name. Other options allow you to place restrictions on the type of file
system to search and the file type on which to match. Figure 4-1 shows the
script's window.Window for script_findEnter the search directory and file name you're looking for in the text
fields at the top of the window. In addition, select any applicable choice
(or choices) from the five toggle buttons. You can further restrict the
search with the option menus. When you have made all the necessary selections,
click OK. If all is well, a window appears shortly thereafter and displays
the results of thefindoperation. An error dialog appears
if you don't specify a search directory or file name, or if the specified
search directory is invalid. For example, suppose you want to find a file
calledtwo_letter_calls, and you think it resides somewhere
in the directory/users/dlm. When you enter the directory
in the Search Directory text field, you inadvertently type/users/dlninstead of /users/dlm. When you click OK
or Apply,script_findcan't find the directory/users/dln, so it creates the error dialog to notify you of this.script_find error dialogWhen you correct the mistake,script_findthen
executes properly and creates adttermwindow within which
it displays the complete path of the file you requested, providing that the
file is found.Window showing complete pathIfscript_findcannot find the file in the specified
directory, nothing appears in thedttermwindow.Analyzing script_findThe structure ofscript_findis similar to a C
program: some functions and callbacks appear first, followed by the main
script.The first two lines of the script are important, and should be included
in everydtkshscript you write:#! /usr/dt/bin/dtksh
. /usr/dt/lib/dtksh/DtFunc.dtshThe first line executes thedtkshsystem and the
second loads thedtkshconvenience functions. The second
line wasn't used in the scripts described in Chapter 2 because those scripts
did not use anydtkshconvenience functions.Functions and Callbackscallbackscript_findscript_findhas the following functions and callbacks:PostErrorDialog()OkCallback()LoadStickyValues()EvalCmd()RetrieveAndSaveCurrentValues()PostErrorDialog()This function is called when an error is detected, such as when the
user enters an invalid directory. The function calls the convenience functionDtkshDisplayErrorDialogDtkshDisplayErrorDialog()which displays a dialog box whose title is Find Error and whose
message is contained in the variable $1, which is passed from the calling
location.dialogPostErrorDialog()
{
     DtDisplayErrorDialog &ldquo;Find Error&rdquo; &ldquo;$1&rdquo; \
     DIALOG_PRIMARY_APPLICATION_MODAL
}The last parameter,DIALOG_PRIMARY_APPLICATION_MODAL, tellsdtkshto create a dialog that
must be responded to before any other interaction can occur.OkCallback()OkCallback()is called when either the OK or Apply
button on the mainscript_findwindow is pressed. If
the OK button is pressed, the script_find window is unmanaged. For either
Apply or OK, the input search directory is validated; if it is invalid, thenOkCallback()callsPostErrorDialog(). If
it is valid, checks are made on the status of the toggle buttons on thescript_findwindow and corresponding adjustments are made to the
variable$CMD. This variable contains the entire command
that is ultimately executed.LoadStickyValues()This function is called from the main program after the window has been
created and managed. It loads all the values from the most recent execution
of the script. These values are saved in a file calledFind.stickyby the functionRetrieveandSaveCurrentValues().EvalCmd()EvalCmd()is used byLoadStickyValues()to evaluate each line inFind.stickyas
adtkshcommand. The following is a list of aFind.stickyfile:XmTextSetString $SD &ldquo;/users/dlm&rdquo;XmTextSetStringXmTextFieldSetInsertionPosition $SD 10XmTextFieldSetInsertionPositionXmTextSetString $FNP &ldquo;two_letter_calls&rdquo;XmTextSetStringXmTextFieldSetInsertionPosition $FNP 16XmTextFieldSetInsertionPositionXtSetValues $FSTYPE menuHistory:$NODIRXtSetValuesXtSetValues $FILETYPE menuHistory:$NOTYPEXtSetValuesXmToggleButtonSetState $T2 true falseXmToggleButtonSetStateXmToggleButtonSetState $T4 true falseXmToggleButtonSetStateRetrievAndSaveCurrentValues()RetrieveAndSaveCurrentValues()retrieves the current
settings and values of the widgets in thescript_findwindow and saves them in the fileFind.sticky.Find.stickyis then used byLoadStickyValues()the next time the script is executed.Main ScriptThe remainder of the script is the equivalent ofMain()in a C program. It initializes the Xt Intrinsics and creates all the widgets
used in thescript_findwindow. Theset -fin the first line tellsdtkshto suppress expansion
of wildcard characters in path names. This is necessary so that thefindcommand can perform this expansion.Thescript_findwindow (see Figure 4-4) consists
of a Form widget with four areas. The areas are marked by Separator widgets,
and each area has several widgets, all of which are children of the Form.Widgets in script_find windowThe widgets are created in sequence by area, from top to bottom.InitializeInitialize is accomplished by the Xt Intrinsics functionXtInitialize:XtInitialize TOPLEVEL find Dtksh $0 &ldquo;${@:-}&rdquo;XtInitializeThis creates a top-level shell that serves as the parent of a Form widget,
which is created next.Create a Form Widgetwidgetformcreate form widgetA Form widget is used as the main parent widget. Form is a Manager
widget that allows you to place constraints on its children. Most of the
widgets in the mainscript_findwindow are children
of the Form. The description of the creation of the rest of the widgets
is separated into the four areas of the window (see Figure 4-4).First AreaThe first area consists of two Label widgets, two TextField widgets,
and a Separator widget that separates the first and second areas.First area ofscript_findWindowThe following code segment creates and positions the first Label widget
and positions it within the Form using theDtkshAnchorTopandDtkshAnchorLeftconvenience functions:XtCreateManagedWidget SDLABEL sdlabel XmLabel $FORM \XtCreateManagedWidgetlabelString:&rdquo;Search Directory:&rdquo; \
  $(DtkshAnchorTop 12) \
  $(DtkshAnchorLeft 10)The following code segment creates and positions the first TextField
widget. Note that it is positioned in relation to both the Form and the
Label widget.XtCreateManagedWidget SD sd XmText $FORM \XtCreateManagedWidgetcolumns:30 \
  value:&rdquo;.&rdquo; \
  $(DtkshAnchorTop 6) \
  $(DtkshRightOf $SDLABEL 10) \
  $(DtkshAnchorRight 10) \
  navigationType:EXCLUSIVE_TAB_GROUP
XmTextFieldSetInsertionPosition $SD 1XmTextFieldSetInsertionPositionThe remaining Label widget and TextField widget are created in the same
manner.The Separator widget is created as a child of the Form widget and positioned
under the second TextField widget.widgetseparatorcreate separator widgetXtCreateManagedWidget SEP sep XmSeparator $FORM \XtCreateManagedWidgetseparatorType:SINGLE_DASHED_LINE \
  $(DtkshUnder $FNP 10) \
  $(DtkshSpanWidth)Second AreaThe second area consists of a RowColumn widget, five ToggleButton gadgets,
and another Separator widget.Second Area ofscript_findWindowA gadget is a widget that relies on its parent for many of its attributes,
thus saving memory resources.The RowColumn widget is created as a child of the Form widget, and
positioned directly under the Separator widget created in the first area.XtCreateManagedWidget RC rc XmRowColumn $FORM \XtCreateManagedWidgetorientation:HORIZONTAL \
       numColumns:3 \
       packing:PACK_COLUMN \
  $(DtkshUnder $SEP 10) \
  $(DtkshSpanWidth 10 10) \
  navigationType:EXCLUSIVE_TAB_GROUPThe five ToggleButton gadgets are created as children of the RowColumn
using the convenience functionDtkshAddButtons:DtkshAddButtons -w $RC XmToggleButtonGadget \DtkshAddButtonsT1 &ldquo;Cross Mount Points&rdquo;           &ldquo;&ldquo;\
  T2 &ldquo;Print Matching Filenames&rdquo;     &ldquo;&ldquo;\
  T3 &ldquo;Search Hidden Subdirectories&rdquo; &ldquo;&ldquo;\
  T4 &ldquo;Follow Symbolic Links&rdquo;        &ldquo;&ldquo;\
  T5 &ldquo;Descend Subdirectories First&rdquo; &ldquo;&ldquo;Another Separator is then created to separate the second and third areas.
Note that this Separator widget ID is calledSEP2.XtCreateManagedWidget SEP2 sep XmSeparator $FORM \XtCreateManagedWidgetseparatorType:SINGLE_DASHED_LINE \
 $(DtkshUnder $RC 10) \
 $(DtkshSpanWidth)Third AreaThe third area consists of two option menus and another Separator widget.Third area ofscript_findWindowThe Option Menus are pull-down menus. When the user clicks the option
menu button, a menu pane with a number of choices appears. The user drags
the pointer to the appropriate choice and releases the mouse button. The
menu pane disappears and the option menu button label displays the new choice.menu, createcreate menuThe first option menu menu pane consists of a number of push button
gadgets, representing various restrictions that can be imposed upon thefindcommand:XmCreatePulldownMenu PANE $FORM paneXmCreatePulldownMenuDtkshAddButtons -w $PANE XmPushButtonGadget \DtkshAddButtonsNODIR &ldquo;no restrictions&rdquo; &ldquo;&ldquo;\
  NFS   &ldquo;nfs&rdquo;             &ldquo;&ldquo;\
  CDFS  &ldquo;cdfs&rdquo;            &ldquo;&ldquo;\
  HFS   &ldquo;hfs&rdquo;             &ldquo;&ldquo;
Next, the Option Menu button itself is created and managed, with the
menu pane just created ($PANE) identified as asubMenuId:
XmCreateOptionMenu FSTYPE $FORM fstype \XmCreateOptionMenulabelString:&rdquo;Restrict Search To File System Type:&rdquo; \
       menuHistory:$NODIR \
       subMenuId:$PANE \
  $(DtkshUnder $SEP2 20) \
  $(DtkshSpanWidth 10 10) \
  navigationType:EXCLUSIVE_TAB_GROUP
XtManageChild $FSTYPEXtManageChildThe second option menu button is created in the same manner. It provides
further restrictions on thefindcommand.The third separator is created in the same manner as the other separators.Fourth AreaThe fourth area consists of four push button widgets, all children of
the Form widget.The four push buttons are used as follows:OK executes thefindcommand with the parameters input in thescript_findwindow and removes thescript_findwindow.Apply executes thefindcommand
with the parameters input in thescript_findwindow
but does not remove thescript_findwindow.Close terminatesscript_findwithout executing thefindcommand.Helpcreates a dialog box with
information on the use ofscript_find.The push buttons are created and positioned in much the same manner
as any of the other widgets, although they are each labeled differently.
The following code segment shows how the OK push button is created:XtCreateManagedWidget OK ok XmPushButton $FORM \XtCreateManagedWidgetlabelString:&rdquo;Ok&rdquo; \
  $(DtkshUnder $SEP3 10) \
  $(DtkshFloatLeft 4) \
  $(DtkshFloatRight 24) \
  $(DtkshAnchorBottom 10)
XtAddCallback $OK activateCallback &ldquo;OkCallback&rdquo;XtAddCallbackSet Operating ParametersXtSetValuesis used to set some initial operating
parameters:XtSetValues $FORM \XtSetValuesinitialFocus:$SD \
  defaultButton:$OK \
  cancelButton:$CLOSE \
  navigationType:EXCLUSIVE_TAB_GROUPInitial focus is set to the
first TextField widget in the first area.Default button is set to the OK push button in
the fourth area.Cancel button is set to the Close button in the
fourth area.Navigation type is set toEXCLUSIVE_TAB_GROUP.The following line configures the TextField widgets so that pressing
the return key does not activate the default button within the Form. See
the description ofEXCLUSIVE_TAB_GROUPin
Appendix B for more information on its use.DtkshSetReturnKeyControls $SD $FNP $FORM $OKRealize and LoopThe last three lines of the script load the previous values of thescript_findwindow, realize the top-level widget, and then enter
a loop waiting for user input.LoadStickyValues
XtRealizeWidget $TOPLEVELXtRealizeWidgetXtMainLoopXtMainLoop