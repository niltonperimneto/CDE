Xt、Xlib、および、Motif依存性XtとXlib依存性については、XlibのC言語インタフェースの第１３章を参照してください。この章では、Motifの国際化に関連する作業について説明します。ロケール管理言語環境言語環境の詳細言語環境言語環境という用語は、アプリケーションがユーザ固有のロケールで正しく実行されるために必要な、ローカライズされたデータのセットのことです。言語環境は、特定の言語に関連付けられた規則を提供します。また、言語環境は、ローカライズされた文字列やアプリケーションが使用するテキストなどの、外部に保存されているデータから構成されています。たとえば、アプリケーションが表示するメニュー項目を、アプリケーションがサポートする言語ごとの別々のファイルに保存する場合があります。このようなデータは、リソース・ファイル、ユーザ・インタフェース定義（UID）ファイル、もしくは、（XPG3準拠システム上の）メッセージ・カタログに保存することができます。ひとつのアプリケーションが動作するときに、単一の言語環境が確立されます。アプリケーションが実行される言語環境は、アプリケーション・ユーザが、環境変数（POSIXシステムのLANGまたはLC_*）、または、xnlLanguageリソースのいずれかによって設定します。アプリケーションは、ユーザの指定に基づいて言語環境を設定します。アプリケーションは、XtSetLanguageProc()関数によって確立される言語プロシージャのsetlocale()関数を使用して、この設定を行なうこともできます。これにより、XtはXtResolvePathname()関数を使用して、リソース、ビットマップ、ユーザ・インタフェース言語（UIL）ファイルをみつけ、ディスプレイごとの言語文字列をキャッシュすることができるようになります。言語プロシージャを提供するアプリケーションは、それ自身のプロシージャを提供することもできますし、Xt言語プロシージャデフォルトのプロシージャを使用することもできます。いずれの場合も、アプリケーションは、ツールキットを初期化する前、かつ、リソース・データベースを（XtAppInitialize()関数を呼び出すなどして）読み込む前に、XtSetLanguageProc()関数を呼び出すことによって言語プロシージャを確立します。言語プロシージャがインストールされると、Xtは初期リソース・データベースの構築中にその言語プロシージャを呼び出します。.Xtは、言語プロシージャが返す値を、そのディスプレイごとの言語文字列として使用します。デフォルトの言語プロシージャは次のタスクを実行します。ロケールを設定します。ロケールの設定は次のように行います。setlocale(LC_ALL,language);上記のlanguageはxnlLanguageリソースの値です。xnlLanguageリソースが設定されていない場合は、空の文字列（&ldquo;&rdquo;）となります。xnlLanguageリソースが設定されていない場合、ロケールは通常、環境変数（POSIXシステムのLANG）から取得されます。XSupportsLocale()関数を呼び出し、設定されたロケールがサポートされているかどうかを確認します。サポートされていない場合は、警告メッセージがだされ、ロケールはCに設定されます。XSetLocaleModifiers()関数を呼び出し、空の文字列を指定します。現在のロケールの値を返します。ANSI Cに基づくシステムでは、これは次の呼び出しの結果です。setlocale(LC_ALL, NULL);アプリケーションは、次ようにXtSetLanguageProc()関数を呼び出すことによって、デフォルトの言語プロシージャを使用することができます。XtSetLanguageProc(NULL, NULL, NULL);
...
toplevel = XtAppInitialize(...);デフォルトでは、Xtは言語プロシージャをインストールしません。アプリケーションがXtSetLanguageProc()関数を呼び出さない場合、xnlLanguageリソースが設定されていれば、Xtはディスプレイごとの言語文字列としてその値を使用します。xnlLanguageリソースが設定されていなければ、XtはLANG環境変数から言語文字列を取得します。XtSetLanguageProcXtSetLanguageProcのデフォルト言語このプロセスから得られるディスプレイごとの言語文字列はインプリメンテーションに依存しており、いったん言語文字列が確立されるとXtは言語文字列を調べるための公の手段を提供しません。アプリケーションは、それ自身の言語プロシージャを提供することによって、希望するプロシージャを使用して言語文字列を設定することができるようになります。フォント管理デスクトップはレンダー・テーブルを使用してテキストを表示します。レンダー・テーブルはレンディションのタグを付けられた集合で、その各々はコンパウンド・ストリングの描画時に使用されるデータを指定します。レンディション、および、レンダー・テーブルについては、「Motif プログラマーズ・ガイド」を参照してください。ローカライズされたテキストの描画コンパウンド・ストリング国際テキストを表示するためのコンパウンド・ストリングコンパウンド・ストリングコンパウンド・ストリングの構造、レンダー・テーブルとの対話操作コンパウンド・ストリング（XmString型）は、プログラムを変更することなく多くの異なったフォントで表示できるように、テキストをエンコードする手段です。レンディション・タグで識別さていれるレンディションが、フォント（および、色など、その他の属性）を指定し、それによってレンディション・タグ付きのコンパウンド・ストリングが描画されます。国際化にとって特に有用なのは、レンディションの集合であるレンダー・テーブルです。テーブルのレンディションの中に、_MOTIF_DEFAULT_LOCALEタグの付いたものがひとつあり、これが現在のロケール用に使用されるレンディションとなります。国際化対応のアプリケーションでは、レンダー・テーブルはリソース・ファイルで指定しなければなりません。前述は、ローカライズされたテキストの描画に関するいくつかの項目について、簡単に概観したものです。詳しくは、「Motif プログラマーズ・ガイド」を参照してください。ローカライズされたテキストの入力VendorShellウィジェット・クラス入力マネージャとしてのVendorShellウィジェット・クラス入力メソッド入力メソッドにおけるVendorShellウィジェット・クラスVendorShellウィジェット・クラスジオメトリ管理におけるVendorShellウィジェット・クラスシステム環境では、VendorShellウィジェット・クラスは、拡張されて入力メソッドへのインタフェースを提供します。VendorShellクラスは、そのジオメトリ管理では子ウィジェットをひとつしか制御しないのに対し、入力メソッドへのインタフェースではそこで必要なすべてのコンポーネントを管理できるように拡張されます。
これらのコンポーネントには、ステータス領域、前編集領域、メイン・ウィンドウ領域VendorShellウィジェット・クラスVendorShellウィジェット・クラスにおけるコンポーネント管理VendorShellウィジェット・クラスにおけるコンポーネント管理のステータス領域VendorShellウィジェット・クラスVendorShellウィジェット・クラスにおけるコンポーネント管理VendorShellウィジェット・クラスにおけるコンポーネント管理の前編集領域VendorShellウィジェット・クラスVendorShellウィジェット・クラスにおけるコンポーネント管理VendorShellウィジェット・クラスにおけるコンポーネント管理のメイン・ウィンドウ領域があります。入力メソッドが、ステータス領域または前編集領域、もしくは、その両方を必要とする場合、VendorShellウィジェットは自動的にステータス領域と前編集領域のインスタンスを生成し、そのジオメトリ・レイアウトを管理します。ステータス領域も前編集領域もすべてVendorShellウィジェットにより内部的に管理され、クライアントからはアクセスすることができません。VendorShellウィジェットの子としてインスタンスを生成されたウィジェットは、メイン・ウィンドウ領域と呼ばれます。入力メソッド入力メソッドの必要条件国際的テキスト入力国際的テキスト入力の入力メソッド入力メソッド入力メソッドの国際的テキスト入力VendorShellウィジェットが使用する入力メソッドは、XmNinputMethodリソース（たとえば@im=alt）により決定されます。デフォルト値Nullは、VendorShellが生成されたときのロケールに関連付けられたデフォルトの入力メソッドを選択することを指示します。このようにユーザは、ロケールを設定すること、XmNinputMethodリソースを設定すること、もしくは、その両方を設定することにより、入力メソッドの選択に影響を与えることができます。
ロケール名は、入力メソッド名を決定するためにXmNinputMethodリソースと連結されます。ロケール名はこのリソースで指定してはなりません。XmNinputMethodリソースのモディファイア名は@im=modifier形式の中におかなければなりません。モディファイアはどの入力メソッドが選択されているかを修飾するのに使用される文字列です。入力メソッドXmNinputMethodリソースの入力メソッドの決定XmNinputMethodリソースの入力メソッドの決定VendorShellウィジェットは入力メソッドを共用できる複数のウィジェットをサポートすることができます。しかし、いつでもキーボードのフォーカスをもつことができる（たとえば、キー・プレスのイベントを受信して、それを入力メソッドに送信する）ウィジェットはひとつだけです。複数のウィジェット（Textウィジェットなど）をサポートするためには、ウィジェットはVendorShellウィジェットの子孫である必要があります。VendorShellウィジェット・クラスはTransientShellウィジェット・クラス、および、TopLevelShellウィジェット・クラスのスーパークラスです。このように、TopLevelShell、もしくは、DialogShellのインスタンスの生成は本質的に、VendorShellウィジェット・クラスのインスタンスの生成です。VendorShellウィジェットは、その子孫のひとつがXmText[Field]インスタンスである場合のみ入力マネージャとして動作します。XmText[Field]インスタンスがVendorShellウィジェットの子孫として生成されるとすぐ、VendorShellは現在のロケールにより指示される特定の入力メソッドに必要な領域を生成します。XmText[Field]インスタンスがマップされずに単に生成された場合でも、VendorShellは前述のようなジオメトリ管理を行います。VendorShellウィジェットは次のことを行います。国際的テキスト入力国際的テキスト入力のVendorShellウィジェット操作システムにインストールされたロケールがサポートしているマルチバイト文字の入力と出力をアプリケーションが処理できるようにします。VendorShellウィジェット操作VendorShellウィジェット操作におけるマルチバイト文字I/Oの処理入力メソッドのインスタンスをXmIm参照関数で定義されている通りに管理します。OnTheSpot、OffTheSpot、OverTheSpot、Root、Noneのいずれかのモードで、前編集領域での前編集をサポートします。ローカライズされたテキストは、フォーカスを変更することによって、複数のText子ウィジェット・ツリー内のどのText子ウィジェットにも入力することができます。子孫ウィジェットのジオメトリ管理を提供します。入力メソッド操作も、スタイル・マネージャのアプリケーションから呼び出されるダイアログ・ボックスによって、ユーザがカスタマイズする可能性があります。詳しくは、共通デスクトップ環境 ユーザーズ・ガイドを参照してください。ジオメトリ管理国際的テキスト入力国際的テキスト入力のジオメトリ管理ジオメトリ管理ジオメトリ管理の国際的テキスト入力VendorShellウィジェットは、入力メソッドのユーザ・インタフェース・コンポーネントのジオメトリ管理とフォーカス管理を必要に応じて提供します。ロケールがそれを保証する場合（たとえば、ロケールが日本語のEUC（拡張UNIXコード）ロケールの場合）、VendorShellウィジェットは、必要な前編集領域またはステータス領域、あるいは、その両方のジオメトリを自動的に割り当てて管理します。現在実行中の前編集によって、補助領域が必要となる場合があります。補助領域が必要な時は、VendorShellウィジェットも補助領域のインスタンスを生成し管理します。通常、VendorShellウィジェットの子は複数のTextウィジェット、および、TextFieldウィジェットを管理することができるコンテナ・ウィジェット（XmBulletinBoardウィジェットやXmRowColumnウィジェットのような）であり、ユーザがマルチバイト文字を入力することができます。このシナリオでは、すべてのTextウィジェットは同一の入力メソッドを共用します。ジオメトリ管理ジオメトリ管理におけるXmBulletinBoardウィジェットジオメトリ管理ジオメトリ管理におけるXmRowColumnウィジェットジオメトリ管理ジオメトリ管理におけるTextウィジェットジオメトリ管理ジオメトリ管理におけるTextFieldウィジェット国際的テキスト入力国際的テキスト入力のマルチバイト文字入力メソッド入力メソッドのTextウィジェットTextウィジェット、入力メソッドステータス領域、前編集領域、補助領域には、アプリケーション・プログラマはアクセスできません。
たとえば、アプリケーション・プログラマがステータス領域のウィンドウIDにアクセスすることは想定されていません。これらのコンポーネントは、必要に応じてVendorShellウィジェット・クラスが管理するので、ユーザはそのインスタンス化や管理について考える必要はありません。アプリケーション・プログラマはVendorShellウィジェット・クラスのXmNpreeditTypeリソースによって、入力メソッドのユーザ・インタフェースのコンポーネントの動作をいくらか制御できます。ジオメトリ管理ジオメトリ管理におけるアプリケーション・プログラマ制御アプリケーション・プログラマによる入力メソッドコンポーネントの制御（OffTheSpotモード、OnTheSpotモード、OverTheSpotモードについてはこのマニュアルで説明しています。）ジオメトリ管理は、入力メソッドのユーザ・インタフェースのコンポーネントすべてに及びます。アプリケーション・プログラム・ウィンドウ（TopLevelShellウィジェット）がサイズ変更されると、入力メソッドのユーザ・インタフェースのコンポーネントもそれに従ってサイズ変更され、その中の前編集された文字列は要求に応じて再配置されます。もちろん、これはシェル・ウィンドウのリサイズ・ポリシーが真であることを仮定しています。VendorShellウィジェットが生成されるとき、特定の入力メソッドが、ステータス領域または前編集領域、もしくは、その両方を必要とするならば、VendorShellのサイズにはこれらのコンポーネントが必要とする領域が考慮されます。前編集領域、および、ステータス領域が必要とする追加の領域は、VendorShellウィジェット領域の一部分です。それらの領域も、サイズ変更が必要な場合は、VendorShellウィジェットにより管理されます。これらの領域（ステータス領域と前編集領域）の潜在的なインスタンス化があるので、現在使用中の入力メソッドに依存して、VendorShellウィジェット領域のサイズが、その子のサイズに正確に適応するように伸縮する必要はありません。VendorShellウィジェット領域のサイズは、その子のジオメトリとこれらの入力メソッドのユーザ・インタフェース領域のジオメトリの両方に適応するように伸縮します。VendorShellウィジェットとその子ウィジェット（メイン・ウィンドウ領域）では、高さが異なるかもしれません（たとえば、20ピクセル）。幅のジオメトリは入力メソッドのユーザ・インタフェースのコンポーネントの影響を受けません。VendorShellウィジェット・クラスVendorShellウィジェット・クラスのサイズVendorShellウィジェット・クラスVendorShellウィジェット・クラスの子ウィジェットのサイズまとめとして、子に要求されたサイズは可能ならば受け付けられます。VendorShellの実際のサイズはその子よりも大きい可能性があります。VendorShellウィジェットとその子のジオメトリを指定する要求は、互いに矛盾しない限り、また、VendorShellウィジェットのサイズ変更が可能な制約内である限り、受け付けられます。矛盾する場合は、子のウィジェット・ジオメトリ要求が優先します。たとえば、子ウィジェットのサイズが100x100と指定されている場合、VendorShellのサイズもまた、100x100と指定されます。子ウィジェットのサイズが100x100となるのに対して、VendorShellのサイズは結果的に100x120となります。子ウィジェットのサイズが指定されていない場合、VendorShellは自分のサイズ指定を受け取る必要があるならば子ウィジェットを縮小します。たとえば、VendorShellのサイズが100x100と指定されておりその子にはサイズが指定されていない場合は、子ウィジェットのサイズは100x80となります。VendorShellウィジェットがサイズ変更不可能ならば、その子のジオメトリ要求が何であっても、VendorShellウィジェットは自分のジオメトリ指定だけを受け取ります。フォーカス管理国際的テキスト入力フォーカス管理VendorShellウィジェット・クラスVendorShellウィジェット・クラスのフォーカス管理フォーカス管理フォーカス管理の国際的テキスト入力多数の文字を使用する言語（日本語や中国語など）では、ユーザがその言語で対話的に文字を構成することができる入力メソッドが必要です。入力メソッド入力メソッドのマルチバイト文字これらの言語では端末のキーボードに適正にマップできる数よりずっと多くの文字が存在するためです。そのような言語で文字を構成する対話的なプロセスは前編集と呼ばれます。前編集自体は入力メソッドにより処理されますが、前編集のユーザ・インタフェースはシステム環境によって決定されます。インタフェースは入力メソッドとシステム環境の間に存在する必要があります。これはシステム環境のVendorShellウィジェットにより実行されます。前編集VendorShellウィジェット・クラスインタフェースとしてのVendorShellウィジェット・クラスインタフェース入力メソッドと共通デスクトップ環境間のインタフェース入力メソッド入力メソッドの共通デスクトップ環境インタフェース共通デスクトップ環境共通デスクトップ環境の入力メソッド・インタフェース前編集は、日本語の前編集の例を示しています。反転表示されている文字列は前編集中の文字列です。この文字列は、ウィンドウにフォーカスをもっていくことにより異なるウィンドウ間を移動させることができます。しかし、一度に行なえる前編集セッションはひとつだけです。日本語の前編集の例フォーカス管理の例として、TopLevelShellウィジェット（VendorShellウィジェットのサブクラス）が、5個のXmTextウィジェットをもつXmBulletinBoardウィジェットの子（メイン・ウィンドウ領域）をもっているとします。そのロケールには前編集領域が必要で、OverTheSpotモードが指定されているとします。VendorShellウィジェットは入力メソッドとしてインスタンスをひとつしか管理しないので、TopLevelShellウィジェット内で一度にひとつの前編集領域しか実行できません。
フォーカスがあるTextウィジェットから別のTextウィジェットへ移動すると、作業中の現在の前編集領域も、現在フォーカスをもっているTextウィジェットのトップに移動します。前のTextウィジェットへのキー処理は一時的に中断されます。前編集完了時の文字列の送信など、それに続く入力メソッドのインタフェースは新しくフォーカスされたTextウィジェットに対して行われます。フォーカス管理フォーカス管理の詳細な例前編集されている文字列は、たとえばマウスをクリックするなどしてフォーカスの位置に移動することができます。エンド・ユーザが前編集を終了して確定した文字列は、再変換できません。文字列はいったん構成されると、確定されます。前編集文字列を確定する操作については、「Motif プログラマーズ・ガイド」の第１１章を参照してください。国際化対応ユーザ・インタフェース言語各国語サポート各国語サポートにおけるユーザ・インタフェース言語（UIL）ユーザ・インタフェース言語（UIL）、UIL <$nopage>参照マルチバイト文字列を文字列リテラルとして解析する機能がユーザ・インタフェース言語（UIL）に追加されています。国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的使用のためのプログラミングのUILにおけるマルチバイト文字の文字列の解析UILファイルは、目的の言語の特性を使用してユーザ・インタフェース定義（UID）を記述することによって作成されます。国際化対応ユーザ・インタフェース言語のプログラミングロケールロケールのUILコンパイラUILコンパイラは標準ではないcharsetをロケール・テキストとして解析します。それには、UILコンパイラがどんなロケール・テキストとも同じロケールで実行される必要があります。国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的使用のためのプログラミングのUILにおける標準でないcharsetの解析国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的使用のためのプログラミングのUILにおけるロケール・テキストウィジェットのロケール・テキストがフォント・セット（ひとつ以上のフォント）を必要とする場合、フォントはリソース・ファイル内にレンダー・テーブルとして指定されなければなりません。UILで特定の文字を使用するために、UILファイルが目的の言語の特性に従って記述され、UIDファイルにコンパイルされます。ローカライズされたテキストを含むUILファイルは、それが実行されるロケールでコンパイルされる必要があります。文字列リテラル国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的使用のためのプログラミングにおけるUILの文字列リテラル文字列リテラル文字列リテラルの国際的UILのためのプログラミング次にリテラル文字列の例を示します。cur_charsetの値は常にdefault_charsetの値に設定されており、それによって文字列リテラルはロケール・テキストを含むことができます。ロケール・テキストをdefault_charsetの値で文字列リテラルに設定するためには、次のように入力します。XmNlabelString = 'XXXXXX';または、XmNlabelString = #default_charset&ldquo;XXXXXX&rdquo;;ロケール・テキストのエンコードと一致するLANG環境変数でUILファイルをコンパイルしてください。そうでないと、文字列リテラルは正しくコンパイルされません。フォントフォント・セットフォント・セットにおける国際的UILのためのプログラミングセット国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的UILのためのプログラミングフォント・セット国際的UILのためのプログラミングフォント・セットはUILソース・プログラミングによって設定することはできません。フォント・セットが必要な場合はいつでも、リソース・ファイルにレンダー・テーブル・リソースとして設定しなければなりません。詳しくは、「Motif プログラマーズ・ガイド」を参照してください。フォント・リストUILにおけるフォント・リスト、リソースを指定フォント・セットと同様に、フォント・リストはリソース・ファイルにレンダー・テーブルとして指定されます。詳しくは、「Motif プログラマーズ・ガイド」を参照してください。レンダー・テーブルUILにおけるレンダー・テーブル、リソースを指定レンダー・テーブルは、レンディション、タブ・リスト、タブ・ストップと同様に、オブジェクトの特殊クラスとして実装されています。詳しくは、「Motif プログラマーズ・ガイド」を参照してください。リソース・ファイル国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的UILのためのプログラミングリソース・ファイル、作成リソース・ファイルリソース・ファイルにおける国際的UILの作成の作成リソース・ファイルリソース・ファイルの国際的UILのための作成必要ならば、次の例のように入力メソッド関連のリソースをリソース・ファイルに設定してください。*preeditType: OverTheSpot, OnTheSpot, OffTheSpot, Root, or None環境国際的使用のためのプログラミング国際的使用のためのプログラミングのUIL国際的UILのためのプログラミング環境の設定国際的UILのための環境の設定の設定環境の設定国際的UIL用の環境の設定ロケールに依存するアプリケーションの場合は、UIDファイルを適切なディレクトリに設定してください。UIDPATH環境変数、または、XAPPLRESDIR環境変数を適切な値に設定してください。たとえば、英語環境（LANG環境変数がen_US）でuil_sampleプログラムを実行するためには、$HOME/en_USディレクトリにラテン文字でuil_sample.uidを設定するか、または、uil_sample.uidをあるディレクトリに設定してUIDPATH環境変数にuil_sample.uidファイルの絶対パスを設定してください。日本語環境（LANG環境変数がja_JP）でuil_sampleプログラムを実行するためには、$HOME/ja_JPディレクトリに日本語（マルチバイト）文字でuil_sample.uidファイルを作成するか、または、uil_sample.uidを一意のディレクトリに置いてUIDPATH環境変数にuil_sample.uidファイルの絶対パスを指定してください。次のリストに、使用できる変数を指定します。%UUIDファイル文字列を指定します。%Nアプリケーションのクラス名を指定します。%LxnlLanguageリソース、または、LC_CTYPEカテゴリの値を指定します。%lxnlLanguageリソース、または、LC_CTYPEカテゴリの言語コンポーネントを指定します。XAPPLRESDIR環境変数が設定されている場合、MrmOpenHierarchy()関数は次の順番でUIDファイルを検索します。環境の設定環境の設定におけるUIDファイルの検索UIDファイル検索MrmOpenHierarchy関数、UIDファイルの検索UIDファイルの検索UIDファイルのパス名$UIDPATH%U$XAPPLRESDIR/%L/uid/%N/%U$XAPPLRESDIR/%l/uid/%N/%U$XAPPLRESDIR/uid/%N/%U$XAPPLRESDIR/%L/uid/%U$XAPPLRESDIR/%l/uid/%U$XAPPLRESDIR/uid/%U$HOME/uid/%U$HOME/%U/usr/lib/X11/%L/uid/%N/%U/usr/lib/X11/%l/uid/%N/%U/usr/lib/X11/uid/%N/%U/usr/lib/X11/%L/uid/%U/usr/lib/X11/%l/uid/%U/usr/lib/X11/uid/%U/usr/include/X11/uid/%UXAPPLRESDIR環境変数が設定されていない場合は、MrmOpenHierarchy()関数は、XAPPLRESDIR環境変数のかわりに$HOMEを使用します。UILのdefault_charsetキャラクタ・セットユーザ・インタフェース言語（UIL）、UIL <$nopage>参照default_charset文字列リテラル文字列リテラル文字列リテラルのUILにおけるdefault_charsetdefault_charset文字列リテラルdefault_charset文字列リテラルを用いれば、どんな文字でも有効な文字列リテラルとして設定することができます。たとえば、LANG環境変数がel_GRである場合、default_charsetの文字列リテラルはどんなギリシャ文字でも含むことができます。LANG環境変数がja_JPである場合、default_charset文字列リテラルは日本語EUCでエンコードされた日本語文字を含むことができます。キャラクタ・セットがひとつも文字列リテラルに設定されていない場合、文字列リテラルのキャラクタ・セットはcur_charsetとして設定されます。そして、システム環境においてはcur_charsetの値は常にdefault_charsetとして設定されます。例: uil_sampleUIL（ユーザ・インタフェース言語）日本語プログラムと英語プログラムの例は、英語環境と日本語環境でのUILプログラム例です。英語環境と日本語環境でのUILプログラムの例次のプログラム例では、LLLはロケール・テキストを指し、日本語、韓国語、中国語（繁体字）、ギリシャ語、フランス語、その他の言語が入ります。uil_sample.uil
!
!  sample uil file - uil_sample.uil
!
!   C source file - uil_sample.c
!
!    Resource file - uil-sample.resource
!
module Test
  version = 'v1.0'
  names = case_sensitive
  objects = {
   XmPushButton = gadget;
  }
!************************************
!  declare callback procedure
!************************************
procedure
  exit_CB;
!***************************************************************
!  declare BulletinBoard as parent of PushButton and Text
!***************************************************************
object
  bb: XmBulletinBoard {
     arguments{
      XmNwidth = 500;
      XmNheight = 200;
     };
     controls{
      XmPushButton    pb1;
      XmText   text1;
     };
  };
!****************************
!  declare PushButton
!****************************
object
  pb1: XmPushButton {
     arguments{
       XmNlabelString = #Normal &ldquo;LLLexit buttonLLL&rdquo;;
       XmNx = 50;
       XmNy = 50;
     };
     callbacks{
       XmNactivateCallback = procedure exit_CB;
     };
  };
!*********************
!  declare Text
!*********************
  text1: XmText {
     arguments{
     XmNx = 50;
     XmNy = 150;
   };
  };
end module;
*
*   C source file - uil_sample.c
*
*/
#include &lt;Mrm/MrmAppl.h>
#include &lt;locale.h>
void exit_CB();
static   MrmHierarchy    hierarchy;
static   MrmType   *class;

/******************************************/
/*  specify the UID hierarchy list         */
/*****************************************/
static   char   *aray_file[]=
     {&ldquo;uil_sample.uid&rdquo;
     };
static   int  num_file = (sizeof aray_file / sizeof
aray_file[0]);
/******************************************************/
/*  define the mapping between UIL procedure names            */
/*  and their addresses            */

/******************************************************/
static   MRMRegisterArg    reglist[]={
     {&ldquo;exit_CB&rdquo;,(caddr_t) exit_CB}UILのコンパウンド・ストリングコンパウンド・ストリングUILのコンパウンド・ストリングUILファイルに文字列を指定する仕組みは３つあります。ヌルで終了する文字列またはコンパウンド・ストリングとしてUIDファイルに保存される可能性のある、文字列リテラルとして指定する。コンパウンド・ストリングとして指定する。ワイド・キャラクタ文字列として指定する。文字列リテラルもコンパウンド・ストリングも両方とも、テキスト、キャラクタ・セット、描画方向から構成されます。方向が明示されていない文字列リテラルとコンパウンド・ストリングについては、UILはキャラクタ・セットから描画方向を推定します。UIL連結演算子（&）は、文字列リテラルとコンパウンド・ストリングの両方を連結します。UILは、文字列リテラルをUIDファイルにヌルで終了する文字列として保存しても、コンパウンド文字列リテラルUILファイルの文字列リテラルストリングとして保存しても、各文字列のキャラクタ・セットと描画方向に関する情報をそのテキストと共に保存します。一般的に次のような場合に、UILは文字列リテラルまたは文字列表現をコンパウンド・ストリングとしてUIDファイルに保存します。文字列表現が、異なるキャラクタ・セットまたは描画方向の２つ以上のリテラルから成る場合リテラルまたは文字列表現が、コンパウンド・ストリングのデータ型をもつ値（データ型がコンパウンド・ストリングであるリソースの値など）として使用されている場合、UILはキャラクタ・セットを指定する多くのキーワードを認識します。UILは認識するキャラクタ・セットそれぞれに、解析方向と、文字列が8ビットか16ビットかなどの解析キャラクタ・セット・キーワードキャラクタ・セット、 UIL CHARACTER_SET関数で定義文字列リテラル文字列リテラルのシンタクス規則を関連付けます。UILCHARACTER_SET関数を使用してキャラクタ・セットを定義することも可能です。文字列リテラルのシンタクスは次のいずれかです。'[character_string]'[#char_set]&ldquo;[character_string]&rdquo;各シンタクスについて、文字列のキャラクタ・セットは次のように決定されます。'character_string'として宣言された文字列の場合、UILコンパイル環境にLANG環境変数が設定されているならば、キャラクタ・セットはLANG環境変数のコード・セット・コンポーネントです。LANG環境変数が設定されていない、または、コード・セットがないならば、キャラクタ・セットはXmFALLBACK_CHARSETの値です。デフォルトではXmFALLBACK_CHARSETの値はISO8859-1ですが、ベンダーによっては異なった値を供給している場合もあります。#char_set&ldquo;string&rdquo;として宣言された文字列の場合、キャラクタ・セットは、char_setです。&ldquo;character_string&rdquo;として宣言された文字列の場合、キャラクタ・セットはモジュールにCHARACTER_SETクローズがあるかどうか、および、UILコンパイラのuse_setlocale_flagが設定されているかどうかに依存します。モジュールにCHARACTER_SETクローズがある場合、キャラクタ・セットはそのクローズで指定されているものになります。モジュールにCHARACTER_SETクローズはないが、uilコマンドが-sオプションで開始された場合、または、Uil()関数がuse_setlocale_flag setで開始された場合は、UILはsetlocale()関数を呼び出して現在のロケールの文字列を解析します。その結果の文字列のキャラクタ・セットはXmFONTLIST_DEFAULT_TAGです。モジュールにCHARACTER_SETクローズがなくuilコマンドが-sオプションなしで開始された場合、または、Uil()関数がuse_setlocale_flagなしで開始された場合は、UILコンパイル環境にLANG環境変数が設定されていれば、キャラクタ・セットはLANG環境変数のコード・セット・コンポーネントです。LANG環境変数が設定されていない、または、コード・セットがないならば、キャラクタ・セットはXmFALLBACK_CHARSETの値になります。UILは常にCOMPOUND_STRING関数を使用して指定された文字列をコンパウンド・ストリングとして保存します。この関数は、キャラクタ・セットの文字列表現とオプション指定、方向、文字列にセパレータを追加するか否か、を引き数としてとります。キャラクタ・セットや方向が指定されない場合は、前節で説明したように、UILは文字列表現からその値を取得します。\（バックスラッシュ）で始まる定義済みの特定のエスケープ・シーケンスは、次の例外を除いて文字列リテラルで表示することができます。 &ndash; 単一引用符で囲まれた文字列は複数の行にわたることができます。各改行文字はバックスラッシュでエスケープされます。二重引用符で囲まれた文字列は複数の行にわたることはできません。 &ndash; エスケープ・シーケンスは、現在のロケールで解析された文字列（ローカライズされた文字列）の中で逐語的に処理されます。