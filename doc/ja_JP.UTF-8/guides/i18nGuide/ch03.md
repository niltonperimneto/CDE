分散国際化についてのガイドライン国際化と分散ネットワークこの章では、国際化と分散ネットワークに関連する作業について説明します。変換の概念この節では、8ビットのネットワークにおける基本的な変換ユーザ名および8ビット・データを、ftp、mail、デスクトップ・クライアントのクライアント間通信などの通信ユーティリティによって、ネットワーク上でネットワーク通信する方法について説明します。データを通信するに際して、まず３つのネットワーク考慮すべき点があります。インタフェースネットワーク通信のインタフェース送信側のコード・セットと受信側のコード・セット通信プロトコルが8ビット・データを許可するか、それとも、7ビット・コード・データに限定されているか。（たとえば、日本のJUNETはJIS（日本工業規格）コードのデータを7ビット・プロトコルで通信します。）プロトコル規則ごとの使用可能な変換エンコードの型。実際に必要な変換は使用される特定のプロトコルに依存します。リモートコード・セットネットワーク・リモート・ホストのコードセットホストがローカル・ホストと同じコード・セットを使用している場合は、次の事項が真となります。プロトコルが8ビット・データを許可する場合、変換は必要ありません。プロトコルが7ビット・データしか許可しない場合、8ビット・コード・ポイントを7ビットASCII値にマップする必要があります。これは、iconvフレームワークと次の7ビット・エンコード方法のうちのひとつを使用して達成することができます。8ビット・データを、POSIX.2仕様のuuencodeおよびuudecodeアルゴリズムに指定されている通りにマップする。任意で、8ビット・データがプロトコルに定義されている7ビット変換エンコードにマップされる。たとえば、Xlibの7ビットISO2022やMIME - 多目的メール（Multipurpose Internet Message Extensions）のbase64があります。リモートコード・セットネットワーク・ローカル・ホストのコード・セットホストのコード・セットがローカル・ホストのコード・セットと異なる場合は、次の２つ事項が適用されます。必要な変換は使用される特定のプロトコルに依存します。プロトコルが8ビット・データを許可する場合、プロトコルは、どちら側がiconv変換を行なうかを指定し、回線上でのエンコードを指定する必要があります。プロトコルによっては、可能なすべてのコード・セットをエンコードし、文字レパートリーを識別することができる8ビット変換エンコードをおすすめします。プロトコルが7ビット・データしか許可しない場合、文字レパートリーを識別する7ビット変換エンコードが必要です。iconviconviconvインタフェースインタフェースネットワーク環境では、通信中のシステムのコード・セットと通信プロトコルによって、ユーザが指定したデータが意味のある方法でリモート・システムに送信されるように、データの変換方法が決定されます。ユーザのデータ（ユーザ名ではありません）を送信側のコード・セットから受信側のコード・セットに変換したり、プロトコルに準拠するよう8ビット・データを7ビット形式に変換したりする必要があります。これを達成するには一様なインタフェースが必要です。次の例は、iconv_open()、iconv()およびiconv_close()の使い方を説明し、iconvインタフェースの使用方法を示しています。変換を行なうためには、iconv_open()の後にiconv()を続ける必要があります。7ビット変換および8ビット変換という用語はそれぞれ、7ビット・データの変換エンコードと8ビット・データの変換エンコードを指すために使用されます。送信側と受信側が同じコード・セットを使用している場合プロトコルが8ビット・データを許可している場合は、同じコード・セットが使用されているので8ビット・データを使用します。変換は必要ありません。プロトコルが7ビット・データしか許可しない場合は、iconvを使用します。送信側cd = iconv_open(locale_codeset, uuencoded);受信側cd = iconv_open(&ldquo;uucode&rdquo;, locale_codeset);送信側と受信側が異なるコード・セットを使用している場合プロトコルが8ビット・データを許可する場合送信側cd = iconv_open(locale_codeset,8-bitinterchange);受信側cd = iconv_open(8-bitinterchange, locale_codeset);プロトコルが7ビット・データしか許可しない場合は、次のようにします。送信側cd = iconv_open(locale_codeset,7-bitinterchange);受信側cd = iconv_open(7-bitinterchange, locale_codeset);locale_codesetはアプリケーションがローカルに使用しているコード・セットを参照します。nl_langinfo(CODESET)関数を使用して現在のロケールに関連付けられたコード・セットを取得することができますが、変換名がnl_langinfo(CODESET)関数からの戻り値と一致するかどうかはインプリメンテーションに依存します。表3-1に、さまざまな条件で変換を実行するためのiconvの使用方法を示します。プロトコルによっては他の変換が必要な場合もあります。変換を実行するためのiconvの使用方法同じコード・セットを使用するシステムとの通信（例: XYZ）異なったコード・セットを使用するシステムとの通信、または、受信側のコード・セットが不明使用する変換7ビット・プロトコル8ビット・プロトコル7ビット・プロトコル8ビット・プロトコルコード XYZ無効最適無効リモート・コード・セットが不明の場合は無効7ビット変換 ISO2022OKOK最適OK8ビット変換 ISO2022 ISO 10646Invalid1OK無効最適7ビット タグなし 引用符付き 印刷可能なuucodeOKOKコード・セットの識別が必要コード・セットの識別が必要8ビット タグなし base64無効OKコード・セットの識別が必要コード・セットの識別が必要1無効とは、選択したコード・セットとプロトコルの型には変換エンコードは使用すべきではないという意味です。状態をもつ変換と状態をもたない変換コード・セット状態をもつエンコードのコード・セットコードコード・セット状態をもたないエンコードのコード・セットセットは、状態をもつエンコードと状態をもたないエンコードの２つのカテゴリに分類することができます。状態をもつエンコードと状態をもたないエンコードの変換状態をもつエンコードの変換状態をもつエンコードは、シフトイン／シフトアウトなどの制御コードのシーケンスを使用して特定のコード値に関連付けられたキャラクタ・セットを変換します。たとえば、コンパウンド・テキストでは、文字のデータ・ストリームで日本語の16ビット・データの開始を示すのに制御シーケンス「ESC$(B」を使用することができます。また、このダブルバイト文字データの終了と8ビットASCIIデータの開始を示すのに、「ESC(B」を使用することができます。この状態をもつエンコードでは、ビット値0x43はシフト状態が不明の場合は解釈できません。EBCDICアジア・コード・セットは、シフトイン／シフトアウト制御を、それぞれ、ダブルバイトとシングルバイトのエンコードの間を切り換えるのに使用します。別のコード・セットへの状態をもつエンコードの変換を実行するために記述されるコンバータは、特別な処理が必要なため少し複雑になる傾向があります。変換状態をもたないエンコードの変換状態をもたないエンコードの変換状態をもたないコード・セットは次の２つの型に分類することができます。シングルバイト・コード・セット（ISO8859ファミリ等）マルチバイト・コード・セット（日本語用PCコードやShft-JIS(SJIS)など）マルチバイト・コード・セットという用語は、1文字をエンコードするのにひとつ以上のバイトを必要とするコード・セットを指すのにも使用されます。マルチバイト・コード・セットは状態をもたないとみなされます。コード・セットが同じキャラクタ・セットを表す場合のみ、変換は意味をもちます。シンプル・テキストの基本的な変換変換状態をもつコード・セットの変換変換シンプル・テキストの変換プログラムがリモート・ホストにある別のプログラムにデータを通信する時には、元のマシンのコード・セットから受信側のコード・セットにデータを変換する必要性があります。
たとえば、PCコードを使用しているPCシステムが、ISO/EUC（国際標準化機構／拡張UNIXコード）エンコードを使用しているワークステーションと通信する必要がある場合などです。また、プログラムがデータを取得したコード・セットとは別のコード・セットでそのデータを表示しなければならない場合も同様です。これらの変換をサポートするために、標準プログラム・インタフェースがXPG4iconv()関数定義に基づいて提供されています。コード・セット変換を行なっているすべてのコンポーネントは、変換のインタフェースとしてiconvを使用しなければなりません。システムは変換のデフォルト・セットをカスタマイズする機構だけでなく、広範囲の変換を提供することが期待されます。iconv変換関数iconviconvのテキスト変換関数あるコード・セットから別のコード・セットへ変換するための変換iconvのテキスト変換共通の方法は、テーブルを使用する方法です。テーブルが大きすぎる場合は、アルゴリズムによる方法が望ましいでしょう。さまざまな要求を満たすため、XPG4にコード・セット変換のフレームワークが定義されています。このフレームワークでは、ひとつのコード・セットから別のコード・セットに変換するために、コンバータを開き、変換を実行し、コンバータを閉じます。iconv関数には、iconv_open()、iconv()、iconv_close()があります。コード・セット・コンバータは、iconv_open()、iconv()、iconv_close()の関数セットのフレームワークの下にあります。これらの関数によって、いくつかの型の異なったコンバータを提供し使用することができます。アプリケーションはこれらの関数を呼び出し、あるコード・セットの文字を別のコード・セットの文字に変換シンプル・テキスト変換関数します。iconvフレームワークにより、コンバータは一様の形式で提供されます。これらのコンバータのアクセスはX/Open XPG4下で標準化されています。Xクライアント間（ICCCM）変換Xクライアント間（ICCCM）変換関数関数Xlibは、変換Xlibにおける変換変換用に次の関数を提供します。X ICCCMマルチバイト関数ICCCMワイド・キャラクタ関数XmbTextPropertyToTextList()XwcTextPropertyToTextList()XmbTextListToTextProperty()XwcTextListToTextProperty()Motifライブラリは、XmCvtXmStringToCT()関数とXmCvtCtToXmString()関数を提供しますが、特定のXmStringタグではハードコードされた前提条件があるためおすすめできません。たとえば、タグがboldの場合、XmCvtXmStringToCT()はインプリメンテーションに依存します。さまざまなプラットフォームに渡って、この関数の動作を世界中すべての地域で保証することはできません。ウィンドウ・タイトルタイトルを設定するウィンドウのタイトル一般的な方法はリソースを使うことです。しかし、ウィンドウのタイトルを直接設定するアプリケーションの場合、ローカライズされたタイトルをウィンドウ・マネージャに送信しなければなりません。次のガイドラインの他にXICCEncodingStyleに定義されたXCompoundTextStyleエンコードを使用してください。コンパウンドウィンドウ・タイトルのガイドラインテキストは、XmbTextListToTextProperty()、もしくは、XwcTextListToTextProperty()のいずれかにより作成することができます。ローカライズされたテキストはWMShellウィジェットのXmNtitleリソース、および、XmNtitleEncodingリソースを使用して表示することができます。ローカライズされたアイコン名はTopLevelShellウィジェットのXmNiconNameリソース、および、XmNiconNameEncodingリソースを使用して表示することができます。ダイアログ・ボックスのローカライズされたタイトルはXmBulletinBoardウィジェットのXmNdialogTitleリソースを使用して表示することができます。ウィンドウ・マネージャはローカライズされた文字列を表示するのに適切なフォント・リストをもっている必要があります。次にローカライズされたタイトルとアイコン名を表示する例ローカライズされたタイトルとアイコン名の例を示します。この例では、コンパウンド・テキストはコンパウンド・ストリングから作成されます。include        &lt;nl_types.h>
Widget         toplevel;
Arg            al[10];
int            ac;
XTextProperty  title;
char           *localized_string;
nl_catd        fd;

XtSetLanguageProc( NULL, NULL, NULL );
fd = catopen( &ldquo;my_prog&rdquo;, 0 );
localized_string = catgets(fd, set_num, mes_num, &ldquo;defaulttitle&rdquo;);
XmbTextListToTextProperty( XtDisplay(toplevel), &amp;localized_string,
       1, XCompoundTextStyle, &amp;title);
ac = 0;
XtSetArg(al[ac], XmNtitle, title.value); ac++;
XtSetArg(al[ac], XmNtitleEncoding, title.encoding); ac++;
XtSetValues(toplevel, al, ac);ウィジェットではなく、ウィンドウを使用している場合は、XmbSetWMProperties()関数が、ローカライズされた文字列を適切なXICCEncodingStyleに自動的に変換します。メールの基本的な変換一般的に、電子メール（email）のストラテジーは、メッセージを受信側のロケールの与えられた情報に最適化するものではなく、電子メールを正規のラベル付け形式にするものです。これは、電子メールの世界では、受信者が異なったロケールにいる可能性を常に仮定しなければならないことを意味しています。デスクトップの世界では、デフォルトの電子メール転送はSMTP（Simple Mail Transfer Protocol）です。SMPTは7ビット転送チャネルしかサポートしません。これをふまえた上で、デスクトップの電子メールのストラテジーには次のような点が挙げられます。送信側は、デフォルトでは（ユーザが別の手順を指示しなければ）、本文の部分を送信側の転送チャネルの標準形式に変換し、本文の部分に使用される文字エンコードでラベル付けします。受信側は、本文の部分を見て文字エンコードをサポートできるかどうかを調べます。サポートできる場合は、本文をローカルのキャラクタ・セットに変換します。さらに、メッセージにMIME形式が使用されているため、8ビットから7ビットへの変換は組み込みのMIME転送エンコード（base64、または、引用符付き 印刷可能な形式）を使用して実行されます。RFC（Request for Comments）1521 MIME標準仕様を参照してください。エンコードとコード・セットコード・セットをエンコード理解するためには、まずキャラクタ・セットを理解することが必要です。キャラクタ・セットは、文字の表示に使用するエンコード値を考慮することなく、ひとつ以上の言語の特定の必要性に基づいてあらかじめ定義された文字の集合です。どのコード・セットを使用するかという選択は、ユーザのデータ処理要求条件に依存します。個々のキャラクタ・セットは異なったエンコード・スキーマを使用してエンコードされます。たとえば、ASCIIキャラクタ・セットは英語の文字のセットを定義します。JIS（日本工業規格）のキャラクタ・セットは日本語で使用される文字のセットを定義します。英語のキャラクタ・セットも日本語のキャラクタ・セットも、異なったコード・セットを使用してエンコードされます。ISO2022規格は、コード化されたキャラクタ・セットを、キャラクタ・セット、および、各文字とそのビット・パターンの１対１の関係を定義する正確な規則の集まりとして定義します。コード・セットはシステムが文字を識別するために使用するビット・パターンを定義します。コード・ページコード・ページはコード・セットに似ていますが、コード・ページ仕様は16列×16行のマトリックスに基づくという制限があります。各列と行の交わりがコード化された文字を定義します。コード・セットコード・セットのストラテジーコード・セットのストラテジー共通オープン・ソフトウェア環境のコード・セット・サポートは、ISO（国際標準化機構）と、ユーザのデータ処理の必要性を満たす業界標準のコード・セットを提供する業界標準コード・セットに基づいています。システムにおける各ロケールは、どのコード・セットを使用し、コード・セット内の文字がどのように処理されるかを定義します。システムに複数のロケールをインストールすることができるので、複数のコード・セットをシステム上の異なったユーザが使用することができます。異なったコード・セットを使用する複数のロケールでシステムが構成されることができる一方で、すべてのシステム・ユーティリティはシステムは単一コード・セットで動作していると仮定します。ほとんどのコマンドはロケールが使用している下層のコード・セットについては何も認識しません。コード・セットの情報はコード・セットに依存しないライブラリ・サブルーチン（国際化対応ライブラリ）によって隠されており、コード・セットに依存しないライブラリ・サブルーチンは、コード・セットに依存するサブルーチンに情報を渡します。多くのプログラムがASCIIに依存しているので、すべてのコード・セットは、7ビットASCIIコード・セットを適正なサブセットとして含んでいます。7ビットASCIIコード・セットはサポートされたすべてのコード・セットに共通しているため、その文字は可搬性のあるキャラクタ・セットとして参照されることもあります。7ビットASCIIコード・セットはISO646定義に基づいており、制御文字、特殊文字、数字（0-9）、大文字と小文字の英語アルファベットを含んでいます。コード・セットコード・セット構造コード・セット構造各コード・セットは次の２つの主な領域に分けられます。GL 0-7列GR 8-F列各コード・セットの最初の２列は、制御文字用にISO規格によって確保されています。C0とC1は、それぞれ、GLとGRの領域用の制御文字を表すのに使用されます。PCコード・セットはC1制御領域を使用してグラフィック文字をエンコードします。残りの６列はグラフィック文字をエンコードするのに使用されます。（を参照してください。）
グラフィック文字は印刷可能な文字とみなされ、制御文字はデバイスとアプリケーションによってある特定の機能を指すために使用されます。コード・セットの概要制御文字ISOコード・セットコード・セットの制御文字定義に基づいて、制御文字は、制御操作を開始、変更、停止します。制御文字はグラフィック文字ではありませんが、場合によってはグラフィック表現をもつことができます。ISO646-IRVキャラクタ・セットの制御文字はサポートされたコード・セットすべてに存在し、C0制御文字のエンコードされた値はコード・セットを通して一貫しています。グラフィック文字各コード・セットコード・セットのグラフィック文字コード・セットは、各文字が固有のコード化された値をもつように、ひとつ以上のキャラクタ・セットに分かれるとみなされます。 ISO規格はエンコード文字用に６列を確保し、グラフィック文字を制御文字でエンコードすることを許可しません。シングルバイト・コード・セット1バイト中の8ビットをすべて使用するコード・セットコード・セットシングルバイト・コード・セットは、ヨーロッパ、中東、その他のアルファベット言語をサポートすることができます。このようなコード・セットはシングルバイト・コード・セットと呼ばれます。これは、制御文字を含まず、エンコードを191文字までに制限します。マルチバイト・コード・セットコード・セットマルチバイト・コード・セットマルチバイト・コード・セットという用語は、特定の文字をエンコードするのに必要なバイト数にかかわりなく、可能なすべてのコード・セットを指します。オペレーティング・システムは１文字をエンコードするのに何ビットでもサポートすることができるため、マルチバイト・コード・セットは、8、16、32、もしくはそれ以上のビットでエンコードされた文字を含むことができます。シングルバイト・コード・セットもマルチバイト・コード・セットとみなされます。EUC（拡張UNIXコード）コード・セットEUC（拡張UNIXコード）コード・セットコード・セットEUCコード・セットは、一部のキャラクタ・セットの中では文字を識別するのに制御文字を使用します。エンコード規則は、ISO2022の7ビット・データおよび8ビット・データのエンコードに関する定義に基づいています。EUCコード・セットは一部のキャラクタ・セットを区切るのに制御文字を使用します。EUCという用語は、そのような一般的なエンコード規則を表します。EUCに基づいたコード・セットはEUCエンコード規則に準拠しますが、特定の場合に関連付けられた特定のキャラクタ・セットも識別します。たとえば、日本語用eucJPはEUCエンコード規則に従ったJIS文字のエンコードを指します。最初のセット（CS0）には常に、ISO646キャラクタ・セットが含まれます。その他のセットはすべて、最上位のビット（MSB）を1に設定しなければならず、文字をエンコードするのに何バイトでも使用することができます。さらに、１セット内のすべての文字は次の項目を満たしていなければなりません。すべての文字をエンコードするのに同じバイト数を使用する。列表示幅（固定幅の端末での列数）が同じである。３番目のセット（CS2）の各文字の前には、常に、制御文字SS2（シングルシフト2, 0x8e）が付きます。EUCに準拠するコード・セットは３番目のセットを識別する目的以外では制御文字SS2を使用しません。４番目のセット（CS3）の各文字の前には、常に、制御文字SS3（シングルシフト3, 0x8f）が付きます。EUCに準拠するコード・セットは４番目のセットを識別する目的以外では制御文字SS3を使用しません。ISO EUCコード・セット次のコード・セットISO EUCコード・セットコード・セットISO EUCコード・セットはISO（国際標準化機構）により設定された定義に基づいています。ISO646-IRVISO8859-1ISO8859-xeucJPeucTWeucKRISO646-IRVISO646-IRVコード・セットISO646-IRVコード・セットコード・セットISO646-IRVコード・セットの詳細は、7ビット・エンコードに基づく情報の処理に使用されるコード・セットを定義します。このコード・セットに関連付けられたキャラクタ・セットはASCII文字から得られます。ISO8859-1ISO8859-1コード・セットISO8859-1コード・セットISO8859-1コード・セットの詳細エンコードは、その他のISO、ANSI（米国規格協会）、ECMA（European Computer Manufacturer's Association）のコード拡張技術に基づいており、それらと互換性のあるシングルバイトのエンコードです。ISO8859エンコードは、各メンバが固有のキャラクタ・セットをもつコード・セットのファミリを定義します。7ビットASCIIコード・セットはISO8859ファミリの各コード・セットの適切なサブセットです。ISO8859-1コード・セットは、ISO Latin-1コード・セットと呼ばれ、次の２つのキャラクタ・セットから成ります。ISO646-IRV GL、7ビットASCIIキャラクタ・セットISO8859-1 GR（ラテン）キャラクタセットこれらの組合わされたキャラクタ・セットは、デンマーク語、オランダ語、英語、フィンランド語、フランス語、ドイツ語、アイスランド語、イタリア語、ノルウェー語、ポルトガル語、スペイン語、スウェーデン語などの西ヨーロッパの言語に必要な文字を含んでいます。ASCIIコード・セットが英語のアルファベットの順番を定義するのに対し、GR文字は特定のどの言語によっても順序付けられません。言語特定の順序はロケールによって定義されます。その他のISO8859コード・セットその他のISO8859コード・セットのリストコード・セットこの節では、その他の重要なISO8859コード・セットその他の重要なISO8859コード・セットをリストします。各コード・セットは、ASCIIキャラクタ・セットとそのコード・セット固有の文字を含んでいます。ISO8859-2ラテン・アルファベット、No. 2、東ヨーロッパアルバニア語チェコスロバキア語英語ドイツ語ハンガリー語ポーランド語ルーマニア語セルビア-クロアチア語スロバキア語スロベニア語ISO8859-5ラテン／キリル・アルファベットブルガリア語ベロルシア語英語マケドニア語ロシア語ウクライナ語ISO8859-6ラテン／アラビア・アルファベット英語アラビア語ISO8859-7ラテン／ギリシャ・アルファベット英語ギリシャ語ISO8859-8ラテン／ヘブライ・アルファベット英語ヘブライ語ISO8859-9ラテン／トルコ・アルファベットデンマーク語オランダ語英語フィンランド語フランス語ドイツ語アイルランド語イタリア語ノルウェー語ポルトガル語スペイン語スウェーデン語トルコ語eucJPeucJPコード・セット日本語用EUCコード・セットeucJPコード・セットの詳細は、シングルバイト文字とマルチバイト文字（2バイトと3バイト）から成ります。エンコードは ISO2022に準拠し、JISおよびEUCの定義に基づいています。を参照してください。eucJPのエンコード`CS`EncodingCharacter Setcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxJIS X0208-1990cs20x8E1xxxxxxxJIS X0201-1976cs30x8F1xxxxxxx 1xxxxxxxJIS X0212-1990JIS X0208-1990情報変換用の日本語グラフィック文字セットのコード（1990年度版）です。この中には、147個の特殊文字、10個の数字、83個のひらがな文字、86個のカタカナ文字、52個のラテン文字、48個のギリシャ文字、66個のキリル文字、32個の線描画要素、6355個の漢字が含まれます。JIS X020163個のカタナカを含む情報変換用のコードです。JIS X0212-1990情報変換用の日本語グラフィック文字セットの補助コード（1990年度版）です。これには、追加の特殊文字が21個、追加のギリシャ文字が21個、追加のキリル文字が26個、追加のラテン文字が27個、発音区別符号のついたラテン文字が171個、追加の漢字が5801個含まれます。eucTWeucTWコード・セット繁体字用のEUCコード・セットeucTWコード・セットの詳細は、シングルバイト文字とマルチバイト文字（2バイトと4バイト）を含む文字から構成されるエンコードです。EUCエンコードはISO2022に準拠し、中華民国とEUC定義によって定義される通り、CNS（Chinese National Standard）に基づいています。を参照してください。eucTWのエンコード`CS`エンコードキャラクタ・セットcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxCNS 11643.1992 - plane 1cs20x8EA21xxxxxxx1xxxxxxxCNS 11643.1992 - plane 2cs30x8EA31xxxxxxx1xxxxxxxCNS 11643.1992 - plane 30x8EB01xxxxxxx1xxxxxxxCNS 11643.1992 - Plane 16CNS 11643-1992は、中国標準変換コード（Chinese Standard Interchange Code）用に16面を定義しており、各面は8836文字（94x94）までサポートすることができます。現在は、1面から7面だけが文字を割り当てられています。CNS文字定義は、CNS 11643-1992規格の16面を示しています。CNS 11643-1992規格の16面面定義文字数EUCエンコード1最も多く使用される6085A1A1-FDCB22番目に多く使用される76508EA2 A1A1 - 8EA2 F2C43Exec、Yuen EDP1センター61488EA3 A1A1 - 8EA3 E2C64RIS2、ベンダー定義72988EA4 A1A1 - 8EA4 EEDC5MOEにより使用されることはめったにない386038EA5 A1A1 - 8EA5 FCD16MOEによる変形キャラクタ・セット163888EA6 A1A1 - 8EA6 E4FA7MOEによる変形キャラクタ・セット265398EA7 A1A1 - 8EA7 E6D58未定義08EA8 A1A1 - 8EA8 FEFE9未定義08EA9 A1A1 - 8EA9 FEFE10未定義08EAA A1A1 - 8EAA FEFE11未定義08EAB A1A1 - 8EAB FEFE12ユーザ定義文字（UDC）08EAC A1A1 - 8EAC FEFE13UDC08EAD A1A1 - 9EAD FEFE14UDC08EAE A1A1 - 8EAE FEFE15UDC08EAF A1A1 - 8EAF FEFE16UDC08EB0 A1A1 - 8EB0 FEFE1EDP: 予算、会計、統計の中央理事会（Center of Directorate, General of Budget, Accounting, and Stistics）2RIS: 居住地情報システム（Residence Information System）3MOE: 文部省（Ministry of Education）eucKR韓国語用EUCコード・セットeucKRコード・セットの詳細は、eucKRコード・セットは、シングルバイト文字とマルチバイト文字から成るエンコードです（を参照）。エンコードはISO2022に準拠し、韓国語標準コード（Korean Standard Code）セットとEUC定義に基づきます。eucKRのエンコード`CS`エンコードキャラクタ・セットcs00xxxxxxxASCIIcs11xxxxxxx1xxxxxxxKS C 5601-1992cs2使用されていないcs3使用されていないKSC 5601-1992（1992年度版 情報変換用韓国語キャラクタ・セットのコード）には、特殊文字が432個、アラビア数字およびローマ数字が30個、ハングル・アルファベット文字が94個、ローマ文字が52個、ギリシャ文字が48個、ラテン文字が27個、日本語の文字が169個、ロシア文字が66個、線描画要素が68個、あらかじめ作成されたハングル文字が2344個、ハンジャ文字が4888個含まれます。ハングル文字は韓国語の単語の音を表します。ひとつのハングル文字は、１個から３個のハングル基本音声記号から構成されます（最初の子音（もしあれば）、母音、最後の子音（もしあれば））。多くの韓国語の単語は、繁体字（韓国ではハンジャと呼ばれています）でも記述することができます。伝統的には、韓国語のテキストは一般的にハングルとハンジャの混合（名詞、動詞、修飾語句という主となる単語にはハンジャ、不変化詞と文法的語尾変化にはハングルを使用）で記述されていました。最近は、人名ではまだハンジャが使用されていることもありますが、ほとんどの韓国語のテキストはすべてハングルで記述されています。