
# データ型データベースのアクセス


この章では、データ型関数とデータ型データベースの使い方について説明します。










# 要約


データ型により、従来のUNIXファイル・システムによって提供される機能を越えて、ファイルとデータの属性が拡張されます。これらの拡張は、アイコン名、記述、アクションなどの属性から成っており、ファイルやデータ上で実行できます。
この情報は、DATA_ATTRIBUTESテーブル(またはデータベース)に名前と値の対として格納されます。
デスクトップは、次のパラグラフで説明する特定のDATA_ATTRIBUTESのセットを使用します。DATA_ATTRIBUTESテーブルは、将来およびアプリケーション固有の成長のために拡張可能ですが、他のアプリケーションでは追加をチェックできないので、このテーブルを拡張することは推奨しません。

データを特定のファイルまたはDATA_CRITERIAテーブルのデータ・エントリに一致させます。DATA_CRITERIAテーブルのエントリは、具体性が高いものから具体性が低いものへ降順に並べられます。
たとえば、/usr/lib/lib*は/usr/*よりも具体的なので、/usr/*より前に置かれます。
ファイルまたはデータの型の検査が要求されると、このテーブルが始めからチェックされ、ファイルまたはデータから与えられた情報を使用してもっとも一致するものが検索されます。
情報に一致するエントリが見つかると、DATA_ATTRIBUTES_NAMEを使用して、正しいDATA_ATTRIBUTESエントリが検索されます。
# ライブラリとヘッダ・ファイルデータ型ライブラリライブラリデータ型アクションライブラリライブラリアクション<Filename>libDtSvc<Default Para Font> ライブラリ<Filename>libXm<Default Para Font> ライブラリ<Filename>libX11<Default Para Font> ライブラリ


データ型を使用するには、libDtSvcライブラリをリンクしてください。
アクションは、通常はデータ型情報と一緒に読み込まれます。
アクションは、libXmライブラリとlibX11ライブラリのリンクを必要とします。
ヘッダ・ファイルは、Dt/Dts.hとDt/Dt.hです。
# デモ・プログラムデータ型デモ・プログラムデモ・プログラムデータ型


データ型データベースの使用例が入っているデモ・プログラムが、/usr/dt/examples/dtdts/datatypes/datatyping.cにあります。
# データの基準とデータの属性データ型検査データの基準データの基準データの属性データ型検査データの属性


データ型検査は、次の 2 つの部分から成ります。

データの基準とデータの属性を格納するデータベース

データベースに問い合わせるルーチンの集まり

データ基準のデータ型検査基準基準、データ型検査属性は、次のとおりです(アルファベット順)。

CONTENT

DATA_ATTRIBUTES_NAME

LINK_NAME

LINK_PATH

MODE

NAME_PATTERN

PATH_PATTERN

データの基準を使用頻度が高いものから順にに示します。
# データの基準(使用頻度順)


`基準`

`説明`

`使用例`

DATA_ATTRIBUTES_NAME

このデータ型の名前。
この値は、データ属性テーブル中のrecord_nameです。

POSTSCRIPT

NAME_PATTERN

このデータに一致するファイル名を記述するシェル・パターン照合表現。デフォルトは空の文字列で、照合の際にファイル名のパターンを無視することを意味します。

*.ps

CONTENT

ファイル・ユーティリティが使用し、マジック・ファイルの開始、型、および値のフィールドとして解釈される 3 つの値。
詳細については、file(1)のマニュアル・ページを参照してください。
デフォルトは空のフィールドで、照合の際に内容を無視することを意味します。
一致する型の例としては、文字列、バイト、ショート、ロング、およびファイル名があります。

0 string !&percnt;

MODE

stat構造体のモード・フィールドに一致する 0 〜 4 文字の文字列。
詳細については、stat(2)のマニュアル・ページを参照してください。
最初の文字は、次のとおりです。

dは、ディレクトリに一致します。

sは、ソケットに一致します。

lは、シンボリック・リンクに一致します。

fは、通常ファイルに一致します。

bは、ブロック・ファイルに一致します。

cは、文字列特殊ファイルに一致します。

f&!x

次の文字は、最初または後続の文字にすることができます。

rは、ユーザ、グループ、またはその他の読み取り権ビットが設定されたファイルに一致します。

wは、ユーザ、グループ、またはその他の書き込み権ビットが設定されたファイルに一致します。

xは、ユーザ、グループ、またはその他の実行あるいはディレクトリ検索のアクセス権ビットが設定されたファイルに一致します。

たとえば、frwのMODEフィールドは、読み取り可能または書き込み可能な通常ファイルに一致します。xは、実行可能なビットまたは検索ビットが設定されたファイルに一致します。

デフォルトは空の文字列で、照合の際にモードを無視することを意味します。

PATH_PATTERN

このデータに一致する絶対パス名を記述するシェル・パターン照合式。
デフォルトは空の文字列で、照合の際にパス・パターンを無視することを意味します。

*/`mysubdir`/*

LINK_NAME

dtdtsfile(4)のマニュアル・ページを参照してください。

LINK_PATH

dtdtsfile(4)のマニュアル・ページを参照してください。

データ型の一般的な属性のいくつかをアルファベット順に示します。

ACTIONS

COPY_TO_ACTION

DESCRIPTION

ICON

INSTANCE_ICON

IS_EXECUTABLE

IS_TEXT

LINK_TO_ACTION

MEDIA

MIME_TYPE

MOVE_TO_ACTION

NAME_TEMPLATE

PROPERTIES

X400_TYPE

これらのデータの属性を使用頻度が高い順にに示します。
# データの属性(使用頻度順)


`基準`

`説明`

`使用例`

DESCRIPTION

人間が読める形式で書かれたデータの説明。
このフィールドがNULLか、データ属性レコードに含まれていない場合は、データ属性の名前が使用されます。

これは、あと書きのページに記述されています。

ICON

このデータに対して使用されるアイコンの名前。
このフィールドがNULLか、データ属性レコードに含まれていない場合は、標準のアイコンが使用されます。
アイコンの命名の詳細については、dtdtsfile(4)を参照してください。

Dtps

PROPERTIES

このデータの属性を示すキーワード。
見える場合と見えない場合があります。
このフィールドがNULLか、データ属性レコードに含まれていない場合は、可視属性とみなされます。
これは、ファイルをユーザから完全に隠したい場合に使用します。

invisible

ACTIONS

このデータに対して実行できるアクションのリスト。
このリストは、この型のオブジェクトに対してユーザに提示されるアクションのアクション・テーブル内の名前を参照します。
このフィールドがNULLか、データ属性レコードに含まれていない場合は、どのアクションも使用できません。

Open,Print

NAME_TEMPLATE フィールド

この型のデータの新規ファイル作成に使用される文字列。
文字列はファイル名とともに１つの引数としてsprintf(3)に渡されます。
デフォルトは空です。
このフィールドをデータ抽出条件テーブルのNAME_PATTERNフィールドと比較してみてください。
テンプレートは&percnt;s.cなど、特定のファイルを作成するために使用されますが、パターンは*.cなどのファイルを検索するために使用されます。

&percnt;s.ps

IS_EXECUTABLE フィールド

この型をアプリケーションとして実行できることをユーザに知らせる文字論理値。IS_EXECUTABLEにtrueが設定されている場合(DtDtsIsTrue()参照)、データは実行可能です。
このフィールドがNULLか、データ属性テーブルに含まれていない、またはtrueに設定されていない場合は、データは実行可能でないとみなされます。

true

MOVE_TO_ACTION

オブジェクトが現在のオブジェクトに移動されるときに実行されるアクションの名前。

FILESYSTEM_MOVE

COPY_TO_ACTION

オブジェクトが現在のオブジェクトにコピーされるときに実行されるアクションの名前。

FILESYSTEM_COPY

LINK_TO_ACTION

オブジェクトが現在のオブジェクトにリンクされるときに実行されるアクションの名前。

FILESYSTEM_LINK

IS_TEXT

このデータ型がテキスト・エディタまたはテキスト・ウィジェットでの操作(表示または編集)に適していることをユーザに知らせる文字列論理値。
データが本来はテキストである場合や、ユーザに対してテキスト形式で表示される場合、IS_TEXTフィールドにはtrueが設定されます(DtDtsIsTrue()参照)。
その基準は、データが人間の言語から成るものか、手動で生成および管理されているか、テキスト・エディタでの表示と編集が可能か、構造体と書式の情報をまったく(あるいはごくわずかしか)ないかという点から決定されます。

詳細な例については、を参照してください。

IS_TEXTフィールドがtrueの場合、データはアプリケーションから直接表示することができます。
すなわち、アプリケーションはXmTextなどのテキスト編集ウィジェットにデータを直接読み込むことができます。

MEDIAフィールド

MEDIAネーム・スペースの名前は、データそのものの形式について記述します。MEDIA名は、ICCCM選択ターゲットとして使用され、データ型レコードのMEDIAフィールドで名前が付けられ、ToolTalkメディア交換メッセージの型パラメータの中で使用されます。

MEDIAネーム・スペースは、ICCCMによって定義された選択ターゲット・アトムのネーム・スペースのサブセットです。
データ書式を指定する選択ターゲットはすべて有効なMEDIA名で、有効なMEDIA名は選択ターゲットとして直接使用することができます。データ書式ではなく、選択の属性(たとえば、LIST_LENGTH)や発生する副作用(たとえば、DELETE)を指定する選択ターゲットもあります。
これらの属性選択ターゲットは、MEDIAネーム・スペースの一部ではありません。

POSTSCRIPT

MIME_TYPE

MEDIAは、デスクトップ内部にあり、データ型を表す一意の名前です。
ただし、外部の他の命名組織もネーム・スペースを設定しています。
MIME RFCで述べられているMultipurpose Internet Message Extensions (MIME)は、そのような外部登録の１つであり、デスクトップ・メール・プログラムのための標準的なネーム・スペースです。

application/postscript

X400_TYPE

X.400型は、構造はMEDIA型に似ていますが、異なる規則を使用して書式化され、異なる命名組織を持ちます。

1 2 840 113556 3 2 850

INSTANCE_ICON フィールド

データのインスタンスのために使用されるアイコンの名前で、通常は&percnt;`name`&percnt;.iconなどの値[dtdtsfile(4)のマニュアル・ページの「バグ」も参照]。INSTANCE_ICONが設定されている場合は、アプリケーションはICONの代わりにそれを使用しなければなりません。
このフィールドがNULLか、データ属性レコードに含まれていない場合は、ICONフィールドが使用されます。

/`myicondir`/&percnt;`name`&percnt;.bm

DATA_HOST

DATA_HOST属性は、*.dtファイルの属性テーブルに追加できるフィールドではありませんが、テーブルから属性を読み込むアプリケーションに返すことができます。
データ型検査サービスはこの属性を自動的に追加して、データ型の読み込み元のホスト・システムを示します。
このフィールドがNULLか、データ属性レコードに含まれていない場合、データ型はローカル・システムから読み込まれています。

IS_TEXTは、MIME_ RFCで述べられているMIMEコンテント・タイプであるMIME_TYPEのテキスト属性とは異なります。MIMEコンテント・タイプからデータがテキスト文字とバイト値のどちらで作成されているかがわかります。
データがテキスト文字で作成され、データにtext/*というラベルが付けられている場合、IS_TEXTフィールドはテキスト形式でユーザに表示するのに適したデータかどうかを判別します。

さまざまなMIME_TYPE属性でのIS_TEXTの使用例をに示します。
# IS_TEXT 属性の例


`説明と MIME_TYPE 属性`

`IS_TEXT 値`

MIME_TYPE text/plainでASCIIにエンコードされた自然言語

IS_TEXT true

MIME_TYPE text/plain; charset=XXXでE*UC、JIS、Unicode、またはISOラテン文字セットにエンコードされた自然言語

IS_TEXT true

MIME_TYPE text/plainによる、
CalendarAppointmentAttrs

IS_TEXT false

MIME_TYPE text/htmlによる、ハイパーテキスト・マークアップ言語 (HTML)

IS_TEXT true

MIME_TYPE application/postscriptによる、PostScript

IS_TEXT false

MIME_TYPE text/plainによる、C プログラム・ソース (C_SRC)

IS_TEXT true

MIME_TYPE text/plainによる、ビットマップとピックスマップ (XBMとXPM)

IS_TEXT false

MIME_TYPE text/plainによる、デスクトップ・アプリケーション・ビルド・サービスのためのプロジェクトまたはモジュール・ファイル

IS_TEXT false

MIME_TYPE text/plainによる、シェル・スクリプト

IS_TEXT false

uuencode(1)により、MIME_TYPE text/plainで生成されたエンコード・テキスト

IS_TEXT false

*MIME_TYPE text/plain

IS_TEXT false

データ型属性の詳細については、dtdtsfile(4)のマニュアル・ページを参照してください。
# データ型関数関数データ型検査データ型検査関数データ型関数関数データ型


データオブジェクトの属性を調べるためには、まずオブジェクトの型を判断し、その型の適切な属性値を求めなければなりません。
データベースにデータ情報を問い合わせるための関数をに示します。
これらの関数はそれぞれ、セクション (3) にマニュアル・ページがあります。
詳細については、該当するマニュアル・ページを参照してください。
# データ型データベース問い合わせ関数データ型検査データベース問い合わせ関数データベース問い合わせ関数、データ型検査


`関数`

`説明`

DtDtsBufferToAttributeList

指定バッファのデータ属性のリストを検索します。

DtDtsBufferToAttributeValue

指定バッファのデータ属性を検索します。

DtDtsBufferToDataType

指定バッファのデータ型名を検索します。

DtDtsDataToDataType

指定データ・セットのデータ型を検索します。

DtDtsDataTypeIsAction

結果として保存されたディレクトリのデータ型を返します。

DtDtsDataTypeNames

使用可能なデータ型のリストを検索します。

DtDtsDataTypeToAttributeList

指定データ属性名の属性リストを検索します。

DtDtsDataTypeToAttributeValue

指定データ属性名の属性値を検索します。

DtDtsFileToAttributeList

指定ファイルのデータ属性のリストを検索します。

DtDtsFileToAttributeValue

指定ファイルのデータ属性値を検索します。

DtDtsFileToDataType

指定ファイルのデータ型を検索します。

DtDtsFindAttribute

属性nameがvalueに一致するデータ型のリストを検索します。

DtDtsFreeAttributeList

指定属性リストのメモリを解放します。

DtDtsFreeAttributeValue

指定属性値のメモリを解放します。

DtDtsFreeDataType

指定データ型名のアプリケーション・メモリを解放します。

DtDtsFreeDataTypeNames

DtDtsDataTypeNamesまたはDtDtsFindAttributeを呼び出して作成されたメモリを解放します。

DtDtsIsTrue

文字列を論理値に変換する簡易関数。

DtDtsRelease

一般的には再読み込みの準備として、データ型データベース情報の読み込みを解除します。

DtDtsSetDataType

指定されたディレクトリのデータ型を設定します。

DtsLoadDataTypes

データ型関数のためにデータベース・フィールドを初期化し、読み込みます。
アクションまたはアクション型を使用する必要がなく、パフォーマンスを向上させたいとき、DtDbLoadの代わりに使用します。
アクションを使用する必要があるときにはDtDbLoadを使用します。

データ型を検査して属性を検索するには、簡易、中間、拡張の３つの方法があります。
# 簡易データ型検査


データ型を検査するための最も簡単な方法は、次の関数を使用することです。

DtDtsFileToAttributeList

DtDtsFileToAttributeValue

これらの関数を使用すると、ファイルの型が検査され、単一の属性またはリスト全体が検索されます。
システム・コールが行われ、データ型の検査と属性の検索が行われます。
次の関数は、中間データ型検査関数を呼び出します。

DtDtsBufferToAttributeList

DtDtsBufferToAttributeValue

バッファは、読み取り/書き込み権を持つ通常ファイルに一致するモードを持つと想定されます。
読み専用バッファの型の検査については、を参照してください。
# 中間データ型検査


データの型を検査して属性を検索する場合、プロセスのデータ型検査部分は、パフォーマンスの点で最もコストがかかります。
データ型の検査を２番目の方法で行うと、データ型検査のための関数と属性検索のための関数を切り離すことによって、パフォーマンスを改善できます。
中間データ型検査には、次の関数を使用します。

DtDtsBufferToDataType

DtDtsFileToDataType

DtDtsDataTypeToAttributeList

DtDtsDataTypeToAttributeValue

アプリケーションが複数の属性値を問い合わせる場合には、これらの関数を使用します。
これらの関数を使用すると、オブジェクトの型が検査され、その型を使用して属性リストから１つ以上の属性を検索します。

データ型検査と属性の検索を行うには、中間データ型検査関数を使用するようにしてください。
これらの関数は、拡張データ型検査関数を呼び出し、バッファについて簡易データ型検査と同様に想定します。
# 拡張データ型検査


拡張データ型検査では、システム・コール、データ型、さらには属性検索も別々に行われます。
拡張データ型検査では、あらかじめ初期化されてデータ型検査関数の一部としては含まれない既存のシステム・コールからのデータを使用するので、コード化が複雑になります。拡張データ型検査には、次の関数を使用してください。

DtDtsDataToDataType

読み取り専用バッファの型を検査するには、st_modeフィールドがS_IFREG | S_IROTH | S_IRGRP | S_IRUSRに設定されたstat構造体が渡されなければなりません。
# アクションであるデータ型(DtDtsDataTypeIsAction)


データベースが読み込まれるとアクションの検査ができるようになるため、データベースの各アクションに対して合成データ型が生成されます。
これらのデータ型は、次の２つの追加の属性を持つことができます。

IS_ACTIONは、このデータ型がアクションであることをユーザに知らせる文字列論理値です。IS_ACTIONに文字列true(大文字と小文字の区別はありません)が設定されている場合、データはアクションです。

IS_SYNTHETICは、このデータ型がACTIONテーブルのエントリから生成されたことをユーザに知らせる文字列論理値です。IS_SYNTHETICにtrueが設定されている場合、データ型は生成されています。
# ドロップ領域としてのオブジェクトの登録データ型検査ドロップ領域としてのオブジェクトの登録ドロップ領域オブジェクトの登録ドロップ領域としてのオブジェクトの登録


アプリケーションがデータ型を定義する場合は、次の手順に従ってプログラマが意図したドラッグ・ドロップ動作のすべてが提供されているか確認してください。

アプリケーションの中で、データ型を定義する必要があるかどうかを指定します。

定義する各データ型について、関連するオブジェクトをドロップ領域にするかどうかを指定します。

ドロップ領域として登録したい各オブジェクトについて、どの操作(移動、コピー、またはリンク)を定義するかを指定します。

各オブジェクトに対して有効なドロップ操作について、適切なドロップ・アクションを定義します(MOVE_TO_ACTION、COPY_TO_ACTION、およびLINK_TO_ACTION属性を設定してください)。

アプリケーションがデータ・オブジェクトのアイコンを表示する場合、それらのアイコンをドロップ領域としてサポートしなければならないこともあります。
その場合、MOVE_TO_ACTION、COPY_TO_ACTION、またはLINK_TO_ACTION属性を問い合わせて、それらのデータ・オブジェクトのドロップ動作を指定する必要があります。
対応する属性値がNULLでない場合だけ、オブジェクトはドロップ操作をサポートしなければなりません。
３つの属性すべてがNULLの値を持つ場合、オブジェクトはドロップ領域として登録されません。
データ型が定義されているオブジェクトの属性を最低１つでも設定すると、アプリケーションはそのオブジェクトをドロップ領域として登録できます。

ユーザがオブジェクトをドロップ領域にドラッグすると、アプリケーションはドロップを行うためにどのジェスチャ(すなわち、どのドラッグ操作)が使用されたかを判断します。
ドラッグ操作とドロップ領域のデータ型に基づいて、アプリケーションはデータ型データベースからドロップ属性を検索します。
次に、DtActionInvokeを呼び出して、次の２つの規則によってパラメータを判断します。

ユーザがオブジェクトAとBをオブジェクトCの上にドロップした場合は、C、A、Bを`args`としてDtActionInvokeを呼び出します。actionはCのMOVE_TO_ACTION、COPY_TO_ACTION、LINK_TO_ACTIONのいずれかの値です。
オブジェクトCがアクションの場合、引き数リストはCを含みません。
また、actionはCです。

ファイル・マネージャとそのディレクトリおよびフォルダ・オブジェクトは、デスクトップが移動、コピー、およびリンクされたドロップ属性を使用する方法を示す例となります。
ユーザは、オブジェクト(ファイル)をディレクトリ・フォルダへドラッグ＆ドロップすることができます。
ファイル・マネージャは、フォルダ・オブジェクトに対して、MOVE_TO_ACTION、COPY_TO_ACTION、およびLINK_TO_ACTIONアクションを定義します。
これらのアクションは、適切なファイル・システムの移動、コピー、およびリンクのためのシステム関数を実行します。

MOVE_TO_ACTION、COPY_TO_ACTION、およびLINK_TO_ACTION属性の定義の例については、/usr/dt/appconfig/types/C/dtfile.dtを参照してください。
ドラッグ＆ドロップの使用方法の詳細については、を参照してください。
# データ型データベースの使用例データ型検査コーディング例コーディング例データ型検査


この節では、データ型検査のコード例を示します。
このコード例は、/usr/dt/examples/dtdts/datatyping.cにあります。
このサンプル・コードは、渡された各ファイルのデータ型、アイコン名、およびサポートされるアクションを表示します。dtactionクライアントを使用して、サポートされているアクションをファイルで実行することもできます。datatypingの使い方は、次のとおりです。datatyping`file1`[`file2``...`]
#include &lt;Xm/Form.h>
#include &lt;Xm/Text.h>
#include &lt;Dt/Dts.h>

#define ApplicationClass &ldquo;DtDatatyping&ldquo;

static Widget text;

static void DisplayTypeInfo(int, char**);

int main(int argc, char **argv)
{
    XtAppContext appContext;
    Widget toplevel, form;
    Arg args[20];
    int n;

    toplevel = XtAppInitialize(&amp;appContext, ApplicationClass,

 NULL,  0,
        argc, argv, NULL, NULL, 0);

    if (argc == 1) {
        printf(&ldquo;&percnt;s: No files specified.\n&ldquo;, argv[0]);
        exit(1);
    }

    form = XmCreateForm(toplevel, &ldquo;form&ldquo;, NULL, 0);
    XtManageChild(form);
    n = 0;
    XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNeditable, False); n++;
    XtSetArg(args[n], XmNeditMode, XmMULTI_LINE_EDIT); n++;
    XtSetArg(args[n], XmNrows, 25); n++;
    XtSetArg(args[n], XmNcolumns, 90); n++;
    text = XmCreateScrolledText(form, &ldquo;text&ldquo;, args, n);
    XtManageChild(text);

    XtRealizeWidget(toplevel);
 if (DtAppInitialize(appContext, XtDisplay(toplevel), toplevel,

  argv[0],
                                                ApplicationClass) == False) {
        printf(&ldquo;&percnt;s: Couldn't initialize Dt\n&ldquo;, argv[0]);
        exit(1);
    }

    DtDbLoad();

    DisplayTypeInfo(argc, argv);

    XtAppMainLoop(appContext);
}

static void DisplayTypeInfo(int argc, char **argv)
{
    char *file;
    char *datatype;
    char *icon;
    char *actions;
    char str[100];
    int i;

    sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;-20s\n&ldquo;,
                &ldquo;File&ldquo;,
                &ldquo;DataType&ldquo;,
                &ldquo;Icon&ldquo;,
                &ldquo;Actions&ldquo;);
    XmTextInsert(text, XmTextGetLastPosition(text), str);

    sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;-20s\n&ldquo;,
                &ldquo;-------------------&ldquo;,
                &ldquo;--------&ldquo;,
                &ldquo;----&ldquo;,
                &ldquo;-------&ldquo;);
    XmTextInsert(text, XmTextGetLastPosition(text), str);

      for(i=1; i &lt; argc; i++) {
        char *file = argv[i];

        /* find out the Dts data type */
        datatype = DtDtsFileToDataType(file);

        if(datatype) {
            /* find the icon attribute for the data type */
            icon = DtDtsDataTypeToAttributeValue(datatype,

   DtDTS_DA_ICON, file);
        }

  /*  Directly find the action attribute for a file */

        actions = DtDtsFileToAttributeValue(file,

   DtDTS_DA_ACTION_LIST);

        sprintf(str, &ldquo;&percnt;-30s\t&percnt;-10s\t&percnt;-8s\t&percnt;s\n&ldquo;,
                        file,
                        datatype?datatype:&ldquo;unknown&ldquo;,
                        icon?icon:&ldquo;unknown&ldquo;,
                        actions?actions:&ldquo;unknown&ldquo;);
        XmTextInsert(text, XmTextGetLastPosition(text), str);

        /* Free the space allocated by Dts */

        DtDtsFreeAttributeValue(icon);
        DtDtsFreeAttributeValue(actions);
        DtDtsFreeDataType(datatype);
    }