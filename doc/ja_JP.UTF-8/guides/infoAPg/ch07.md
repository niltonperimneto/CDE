インフォメーション・マネージャのスタイル・シートの理解スタイル・シート理解スタイル・シートは、文書型定義における要素のオンラインおよび印刷フォーマットの属性を定義することによって、インフォメーション・マネージャのブラウザによるドキュメントの表示形式を制御します。インフォメーション・マネージャのスタイル・シートは、スタイル・シート文書型定義dtinfoStyle.dtdに準拠していなければなりません。スタイル・シートは、ブックケース規定ドキュメントの一部として指定されます。インフォメーション・マネージャでインフォメーション・ライブラリを構築するには、ブックケースのレベルで、デフォルトのスタイル・シートを参照しなければなりません。詳細については、dtinfoBook.dtd(5)マニュアル・ページ、「構築過程とツール」、および「スタイル・シートの使用」を参照してください。スタイル・シートの作成に関する特定の情報については、以下を参照してください。「スタイル・シートの構造」「スタイル・シートの作成」「スタイル機能」スタイル・シートの構造スタイル・シートの構造スタイル・シートは、AutoNumber宣言から成り、この後にPathステートメントおよびスタイル規定が続きます。スタイル・シートは、ブックケース、ブック、およびセクションのレベルで指定することができます。ブックケース以下のレベルでスタイル・シートを指定しない場合、そのレベルのスタイルは、それが含む要素から継承されます。要素にスタイル・シートが指定されていない場合、テキストは、グローバルな Xresources ファイルで指定されているデフォルト値、14ポイントの Helvetica で、インフォメーション・マネージャの表示ウィンドウに表示されます。印刷のときのデフォルトのフォントは、12ポイントの Helvetica です。継承に関する詳細についていは、「継承の理解」を参照してください。各スタイル・シートには、あるブックケースのドキュメントの範囲内で、一意の名前がなければなりません。インフォメーション・マネージャは、スタイル・シート名を、ブックケースおよびそのブックとセクションそれぞれにおける参照として使用します。スタイル・シートの作成は、基本的には、要素選択の問題です。これは、Pathステートメントを通じて行うもので、名前、コンテキスト、および属性によって選択します。それから、Pathにタイポグラフィック・プロパティを割り当てます。パスのないSelect機能を使用して、属性値、絶対位置、あるいは相対位置によって要素を選択することができます。スタイル・シートのPathステートメントを使用して、OnlineあるいはPrint(ハード・コピー) 機能で、フォーマット対象の要素を識別することもできます。OnlineおよびPrint機能の設定は、次に示す「印刷固有の機能」を除いて、機能、記述、および規定と合致します。MediumPageBreak次に、Chapter 属性のフォーマット属性を指定するスタイル・シート構文の部分的な例を示します。これは、ある種のドキュメントにおいては、DTINFO.Section設計様式を使用する最大の要素です。スタイル・シートの最初のPathとして、最大のDTINFO.Sectionを指定することは、デフォルトのレンダリング属性を設定するとき、有用なことがあります。<Path>
Chapter</Path>
<online>
   <wrap word>
   <margin left=20 right=20>
   <font fallback=sans weight=medium  slant=roman size=14>
   <family name=helvetica charset="iso8859-1">
   </font>
</online>パスの指定パスの指定パス・ステートメントは、もっとも外側の要素からスタイル・シートで指定された機能によって影響を受けるある要素までの階層的なパスを指定します。与えられた階層構造において、特定の要素を識別するには、その要素への最少限の一意なパスを指定するだけです。パスは、常に、コンテキストにおいて要素または要素クラスと一致する最初のパス指定によって解決されます。特別な要素Selectステートメントと同じようにワイルドカード文字を使用して、フォーマット対象の特定の要素を識別することができます。Selectステートメントについては、「Select ステートメントの使用」で、説明しています。次に示す図では、Chapter 要素には、その後に２つの Paragraph 要素とひとつの Section 要素が続く Title があります。また、Section 要素には、Title と２つの Paragraph 要素があります。
# 単純なドキュメント階層構造
この図に基づく Section 要素の完全なパスは、以下のようになります。<Path> Chapter Section </Path>ダイアグラムの階層構造には、ただひとつの Section 要素があるため、Section 要素を識別するには、要素名だけで十分です。Section 要素内に含まれる Paragraph 要素を識別するパスは、以下のようになります。<Path>Chapter Section Paragraph </Path>スタイル・シートにおいて、パスを指定する場合、２つのワイルドカードが使用可能です。疑問符 (?) は、生起するすべての単一要素を示します。アスタリスク (*) は、生起する要素を０個を含むいくつでも示します。上の図に基づくと、次に示す２つのステートメントは、同じ要素を指定します。<Path> Chapter Section Title </Path><Path> Chapter ? Title </Path>しかしながら、上記の２つの PATH ステートメントとは異なり、次の PATH ステートメントは、セクションに含まれる Title ステートメント以外も選択します。<Path> Chapter * Title </Path>Select ステートメントの使用select ステートメントSelectステートメントによって、異なるスタイルを、異なるコンテキストの同じ要素に適用することが可能になります。たとえば、Selectを使用することによって、フォーマット属性の異なるセットを、特定の型のヘッド（リスト内の副次的な編成か、警告の一部か）に続くかどうかに依存して、段落要素に適用することができます。これは、Selectステートメントによって、要素の属性値またはその位置による要素の特定のインスタンスとの一致を行うことができるために、可能です。Path内の各要素は、それ自身のSelectステートメントをもつことができます。Selectステートメントは、単純な比較演算子、「等しい」(==)、「等しくない」(!=)、およびブール演算子、「および」 (&&) と「または」(||) を使用します。属性による要素の識別要素の属性値を使用して、要素を識別することができます。たとえば、Paragraph 要素が、次に示すような開始タグをもっていたとしましょう。<PARAGRAPH label="UNIque">この場合、Paragraph 要素へのパスは、以下のように指定することができます。<PATH>Paragraph <Select>@label == "UNIque"</Select>
</PATH>この方法では、"@" 文字の後の属性名として、どのような要素属性でも使用することができます。同じように、次のステートメントにより、同じ Paragraph 要素を明示的に排除することも可能です。<PATH>Paragraph <Select>@label != "UNIque"</Select>
</PATH>位置による要素の識別要素の階層構造における要素の相対位置または絶対位置に基づくモデルを使用して、位置による要素の識別を行うことができます。その識別キーワードによって２つの方法があります。解析木における要素の絶対位置。"Position"キーワードを使用します。兄弟位置間の要素の相対位置。"Sibling"キーワードを使用します。これら２つのモデルは、どのようなPathステートメントであっても、いっしょに使用することができます。いずれも、値として数値を必要としますが、特別な値"#LAST"を使用して、要素のリストにおける最後の要素を指定することもできます。以下に示す文書型定義フラグメントとドキュメント・インスタンス・フラグメントの例は、２つの可能な絶対位置および相対位置による要素の選択モデルを示しています。続くサンプルのPathステートメントは、２つのモデルを使用して、特定の要素項目を選択するためのこれらの選択機構の利用方法を示しています。文書型定義フラグメントとドキュメント・インスタンス・フラグメント<!ELEMENT List - - (Title?,Item+)> 
<!ATTLIST List  Type     (Bulleted|Numbered)    "Bulleted">  
<!ELEMENT Title - - #PCDATA > 
<!ELEMENT Item  - - #PCDATA > 
INSTANCE A:                         INSTANCE B: 
<List Type="Numbered">           <List Type="Numbered"> 
<Item>Fee</item>              <Title>Fee Fie Foe Fum</item> 
<Item>Fie</item>              <Item>Fee</item> 
<Item>Foe</item>              <Item>Fie</item> 
<Item>Fum</item>              <Item>Foe</item> 
</List>                          <Item>Fum</item>                            
                                    </List>絶対位置モデルSELECTステートメントの"Position"キーワードを使用することにより、解析木におけるその絶対位置に基づいて、要素を選択することができます。上で示した文書型定義フラグメントとドキュメント・インスタンス・フラグメントの例では、コンテント・モデルにより、オプションの Title 要素が可能ですが、インスタンス A では、オプションの Title 要素を使用していません。次に示すパスは、インスタンス A の最初の Item 要素を識別します。<PATH> List <Select>@Type == "Numbered"</Select>  Item <Select>position == 1 </Select>
</PATH>先行するパスが、インスタンス B のために使用されたとすれば、インフォメーション・マネージャは、最初の Item 要素を見つけることができません。なぜなら、その解析木における絶対位置は２番目であり、その直近の Title の後だからです。次に示すパスは、インスタンス A の残りの Item 要素を選択します。<PATH> List <Select>@Type == "Numbered"</Select>  Item <Select>position != 1 </Select>
</PATH>先行するパスが、インスタンス B において使用されたとすれば、すべての Item 要素が一致することになります。相対位置モデルSelectステートメントの"Sibling"キーワードを使用することにより、解析木における類似の兄弟への相対的な位置に基づいて、要素を選択することができます。このモデルは、類似の要素グループにおいて、最初の要素と最後の要素を選択するための直接的なメソッドを提供します。次に示すステートメントにより、インスタンス A あるいはインスタンス B のどちらかの最初の要素を識別することができます。<PATH> List <Select>@Type == "Numbered"</Select>   Item <Select> sibling == 1 </Select>
</PATH>次に示すパスは、両インスタンスの最後の Item 要素を識別します。<PATH> List <Select>@Type == "Numbered"</Select>   Item <Select> sibling == "#LAST" </Select>
</PATH>選択式のグループ化次に示す比較演算子を使用することにより、Select式をグループ化して、最初でも最後でもない要素を識別することができます。&& -- 「論理積」演算子。
すべての式が真ならば、真です。|| -- 「論理和」演算子。
いずれかの式が真ならば、真です。グループ化演算子が提供されていない場合でも、自然な左から右への論理は、類似の結果をもたらします。次に示すパスは、インスタンス B のための複合的なSelectステートメントを示しています。<PATH> List <Select>@Type == "Numbered"</Select>     Item <Select>sibling != 1 && position != "#LAST" </Select>
</PATH>上で説明したように、Selectステートメントの内容は、位置または属性値のいずれかを指定することができます。そして、ひとつ以上のSelectが、Pathステートメントにおいて（各要素名ごとにひとつ）出現することができます。次に、Selectステートメントの使用に関する他のガイドラインを示します。position ==n要素の文字列における相対位置が、nに等しければ、その要素を選択します。たとえば、position == 3は、その位置が 3 に等しい要素を選択します。
先行する空白は必須であり、その後に==が続かなければなりません。position !=n要素の文字列における相対位置が、nに等しくなければ、その要素を選択します。たとえば、position != 3は、その位置が 3 に等しくない要素を選択します。
先行する空白は必須であり、その後に!=が続かなければなりません。@attribute=="string"attributeがstringに等しい要素を選択します。たとえば、@label == "chapter"は、値 "chapter" の Label 属性をもつ要素を選択します。
先行する空白は必須であり、その後に==が続かなければなりません。@attribute!= "string"attributeがstringに等しくない要素を選択します。たとえば、@label != "chapter"は、値 "chapter"でないLabel 属性をもつ要素を選択します。
先行する空白は必須であり、その後に!=が続かなければなりません。次の例は、値 "chapter" の Label 属性をもつ Title 要素を指定します。<Path> * title <Select>@label == "chapter"</Select>
</Path>インフォメーション・マネージャは、ワイルドカードによる選択をサポートしていません。たとえば、<Path> * <Select>@label == "Chapter" </Select></Path>は、サポートしていません。要素の階層構造と DTINFO.Sectionスタイル・シートにおいては、ソースの文書型定義によって定義される要素の階層構造が、フォーマットを必要とする唯一の要素の階層構造であるとは、必ずしも限りません。DTINFO.Sectionの設計様式が適用される各要素は、ユーザが指定しなければならない独立した要素の階層構造の根を形成します。すなわち、図「単純なドキュメントの階層構造」における要素のパスは、DTINFO.Sectionが Chapter 要素にのみ適用されていれば、真です。しかしながら、DTINFO.Sectionが、Chapter と Section の両方に適用されると、Section 要素に含まれる Paragraph 要素のための最小限の一意なパスは、以下のようになります。<Path> Section Paragraph
</Path>同様に、Chapter 要素に含まれる Paragraph 要素のためのパスは、以下のようになります。<Path> Chapter Paragraph
</Path>継承の理解スタイル・シートの機能には、含んでいる親の要素から継承されるものもあります。以下に示す短いスタイル・シートの例が示すように、スタイル・シートが親または子の要素に別のフォーマット属性を指定するまで、子の要素は継承可能なフォーマット属性を表示します。親のスタイル指定が変更されると、そのすべての子の要素は、同じ変更を継承します。例のスタイル・シートは、要素 SECT1、SECT1 TITLE、および PARA のためのPathステートメントを示しています。Font、Family、およびMarginが SECT1 要素で設定され、SECT1 に含まれる別の要素（SECT1 TITLE と PARA）によって継承されることに注意してください。２番目のPathステートメントでは、すべての SECT1 TITLE 要素のフォント・サイズおよびウェイトの値が、18-point、medium にリセットされています。これらの新規の値は、PARA が SECT1 の子であり SECT1 TITLE の子ではないため、PARA によって継承されません。短いスタイル・シートの例<STYLESHEET Name=General>

<path>
SECT1 </path>
<Online>
   <Font Fallback=sans Weight=medium Slant=roman Size=14>
   <Family Name=helvetica Charset=iso8859-1>
   <Margin Left=20 Right=20 Top=30 Bottom=30>
</Online>

<path> SECT1 TITLE </path>
<Online>
   <Font  Weight=bold  Size=18> 
</Online>

<path>
PARA </path>
<Online>
   <Linebreak both>
   <Layout  ASpace=6  BSpace=6> 
</Online>

</STYLESHEET>継承されるスタイル指定は、以下のとおりです。FontHighLightIgnoreLayoutMarginMedium継承されないスタイル指定は、以下のとおりです。BorderCellColFormatLineBreakPageBreakPositionPrefix and SuffixRowTableTGroup